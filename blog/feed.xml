<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kamal Marhubi</title>
    <description></description>
    <link>http://kamalmarhubi.com/</link>
    <atom:link href="http://kamalmarhubi.com/blog/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 25 Apr 2016 21:35:29 -0400</pubDate>
    <lastBuildDate>Mon, 25 Apr 2016 21:35:29 -0400</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Segfaults are our friends and teachers</title>
        <description>&lt;p&gt;This afternoon, I got a segmentation fault in a Rust program, and was confused. This is Rust, I shouldn’t get segfaults! I quickly checked the couple of places I used &lt;code&gt;unsafe&lt;/code&gt;, and they were either calling C functions (and checking the errors), or telling the compiler not to initialize some memory because I was going to write into it unconditionally before reading from it.&lt;/p&gt;

&lt;p&gt;So, everything should be fine, right?&lt;/p&gt;

&lt;p&gt;Evidently not:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo build --quiet
$ target/debug/kern-value 1
Segmentation fault
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ok-but-what-is-a-segfault&quot;&gt;ok, but what is a segfault?&lt;/h2&gt;

&lt;p&gt;If you’ve written some C, you’ve almost certainly seen a segmentation fault at some point. I spent a long time thinking of it as a ‘thing that happens when you use pointers wrong in C’. That’s mostly true, but a segmentation fault actually has a very specific meaning. You get one when a process tries to access memory in a way that it’s not allowed to, or accessing invalid memory.&lt;/p&gt;

&lt;p&gt;Here’s an example of a really simple program that will segfault:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat segfault.c
#include &amp;lt;stdio.h&amp;gt;

int main(void) {
    char *uninitialized;
    printf(&quot;%c&quot;, *uninitialized);

    return 0;
}
$ gcc segfault.c
$ ./a.out
Segmentation fault
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program segfaults because the entire stack is set to &lt;code&gt;0&lt;/code&gt; at program start. This includes the &lt;code&gt;uninitialized&lt;/code&gt; pointer, which will be a null pointer, pointing to &lt;code&gt;0x0&lt;/code&gt;. When the program tries to print the value it points to, it attempts to read from the null address. That address is invalid, and that’s why we get a segmentation fault.&lt;/p&gt;

&lt;p&gt;Segmentation faults are raised by the memory management unit (MMU), which is a piece of hardware! Sections of memory can have different access permissions on them: read, write, and execute. Operating systems use this to isolate processes, and to protect kernel memory from being written to by user code.&lt;/p&gt;

&lt;p&gt;If a process tries to write to read-only memory, say, or execute non-executable memory, then the MMU hardware tells the kernel there was a segmentation fault. The kernel delivers the news to the process as a signal: &lt;code&gt;SIGSEGV&lt;/code&gt;. By default, that terminates the process.&lt;/p&gt;

&lt;h2 id=&quot;how-we-got-the-segfault&quot;&gt;how we got the segfault&lt;/h2&gt;

&lt;p&gt;Some context: I’m playing around with reading and writing to pipes with large buffers. I’d previously been setting the pipe size to 1 MB, which is the maximum an unprivileged process can set it to on my machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /proc/sys/fs/pipe-max-size
1048576
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My code had a constant &lt;code&gt;PIPE_SIZE&lt;/code&gt; for the size of the pipe. I was &lt;em&gt;also&lt;/em&gt; using it as the size of a stack-allocated buffer. For my experiments, I’d just changed that constant from 1 MB to 16 MB to test bigger pipes when running as root.&lt;/p&gt;

&lt;p&gt;Realising this this set off something in the back of my mind: I vaguely remembered that stacks on Linux default to 8MB. Could the segfault be from going past the stack limit?&lt;/p&gt;

&lt;p&gt;I switched to C to verify it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat -n test-stack.c
     1  #include &amp;lt;stdio.h&amp;gt;
     2
     3  #define BUF_SIZE (16*1024*1024)
     4
     5  int main(void) {
     6      char buf[BUF_SIZE];
     7      printf(&quot;%lu\n&quot;, sizeof(buf));
     8
     9      return 0;
    10  }
$ gcc -Wall -Wextra -Werror test-stack.c
$ ./a.out
Segmentation fault
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aha! A pretty minimal C program that has the same result. This program allocates a 16 MB array on the stack, and then prints its size. Except it segfaults instead. With the &lt;code&gt;BUF_SIZE&lt;/code&gt; set to 8 KB less than 8 MB, everything works. With it set to 8 MB, it segfaults.&lt;sup id=&quot;fnref:why-8-mb&quot;&gt;&lt;a href=&quot;#fn:why-8-mb&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; Hypothesis confirmed!&lt;sup id=&quot;fnref:why-rust-ok&quot;&gt;&lt;a href=&quot;#fn:why-rust-ok&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;seeing-which-instruction-failed&quot;&gt;seeing which instruction failed&lt;/h2&gt;

&lt;p&gt;I wanted to get an idea of exactly &lt;em&gt;when&lt;/em&gt; the segfault happened, so I ran it under gdb:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -g -Wall -Wextra -Werror test-stack.c
$ gdb -silent a.out
Reading symbols from a.out...done.
(gdb) run
Starting program: /tmp/a.out

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400520 in main () at test-stack.c:7
7               printf(&quot;%lu\n&quot;, sizeof(buf));
(gdb) backtrace
#0  0x0000000000400520 in main () at test-stack.c:7
(gdb) disassemble
Dump of assembler code for function main:
   0x0000000000400506 &amp;lt;+0&amp;gt;:     push   %rbp
   0x0000000000400507 &amp;lt;+1&amp;gt;:     mov    %rsp,%rbp
   0x000000000040050a &amp;lt;+4&amp;gt;:     sub    $0x1000000,%rsp
   0x0000000000400511 &amp;lt;+11&amp;gt;:    mov    $0x1000000,%esi
   0x0000000000400516 &amp;lt;+16&amp;gt;:    mov    $0x4005b4,%edi
   0x000000000040051b &amp;lt;+21&amp;gt;:    mov    $0x0,%eax
=&amp;gt; 0x0000000000400520 &amp;lt;+26&amp;gt;:    callq  0x4003e0 &amp;lt;printf@plt&amp;gt;
   0x0000000000400525 &amp;lt;+31&amp;gt;:    mov    $0x0,%eax
   0x000000000040052a &amp;lt;+36&amp;gt;:    leaveq
   0x000000000040052b &amp;lt;+37&amp;gt;:    retq
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the failure was on the call to &lt;code&gt;printf&lt;/code&gt;. &lt;code&gt;0x1000000&lt;/code&gt; is 16 MB, the size of the buffer. The &lt;code&gt;sub    $0x1000000,%rsp&lt;/code&gt; instruction is modifying the stack pointer register &lt;code&gt;%rsp&lt;/code&gt; to make space for the buffer. When we get to the &lt;code&gt;callq&lt;/code&gt; instruction, things exploded!&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;callq&lt;/code&gt; instruction on x86 first pushes the return address onto the stack, then jumps to the called function. The return address is the current value instruction pointer register &lt;code&gt;%ip&lt;/code&gt;, and is where the &lt;code&gt;ret&lt;/code&gt; instruction in &lt;code&gt;printf&lt;/code&gt; will jump back to. The segfault happens at this point: the CPU attempts to store the return address somewhere outside of the region of memory that’s set aside for the stack, and boom!&lt;/p&gt;

&lt;h2 id=&quot;luck-and-guard-pages&quot;&gt;luck and guard pages&lt;/h2&gt;

&lt;p&gt;I think we’re actually kind of lucky to get a segfault. It’s quite possible the bit of memory that’s a few megabytes past our stack &lt;em&gt;was&lt;/em&gt; writeable by our process. We’d then go happily corrupting whatever memory was there and probably all kinds of bad things would happen. Segmentation faults are actually our friends!&lt;/p&gt;

&lt;p&gt;Modern compilers have stack protection features that help detect overflows. I’m &lt;em&gt;very&lt;/em&gt; hazy on the details, but I think they include setting some pages of memory just after the stack to be read only. These are called guard pages. Attempts to write there would result in a segmentation fault. This helps catch stack overflow attempts that involve marching off the end of the stack. However, writing 8 MB after the end of the stack is beyond the guard pages, so we &lt;em&gt;could&lt;/em&gt; have ended up in writeable memory.&lt;/p&gt;

&lt;h2 id=&quot;setting-stack-size-limits-in-the-shell-ulimit&quot;&gt;setting stack size limits in the shell: ulimit&lt;/h2&gt;

&lt;p&gt;I took this as an opportunity to Learn. I wanted to make this program run without changing its source. At first I thought I could set the stack size with compiler options, but some searching revealed this wasn’t true on Linux. It turns out you can set it with the &lt;code&gt;ulimit&lt;/code&gt; shell built-in&lt;sup id=&quot;fnref:why-builtin&quot;&gt;&lt;a href=&quot;#fn:why-builtin&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ulimit --soft --stack-size 32768
$ ./a.out
16777216
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Success, and without changing the source &lt;em&gt;or&lt;/em&gt; the binary! The &lt;code&gt;--stack-size&lt;/code&gt; flag says we’re setting the stack size to 32768 KB or 32 MB. The &lt;code&gt;--soft&lt;/code&gt; flag says to set the soft limit. I’ll just paste from my &lt;code&gt;man ulimit&lt;/code&gt; on my system to explain the difference between hard and soft limits—the &lt;code&gt;-S&lt;/code&gt; flag is short for &lt;code&gt;--soft&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A hard limit can only be decreased. Once it is set it cannot be increased; a soft limit may be increased up to the value of the hard limit. If neither &lt;code&gt;-H&lt;/code&gt; nor &lt;code&gt;-S&lt;/code&gt; is specified, both the soft and hard limits are updated when assigning a new limit value, and the soft limit is used when reporting the current value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;setting-stack-size-limits-from-inside-your-program-setrlimit2&quot;&gt;setting stack size limits from inside your program: setrlimit(2)&lt;/h2&gt;

&lt;p&gt;If you use a lot of stack, it’s not great to force the user to run &lt;code&gt;ulimit&lt;/code&gt; before running your program. Instead, you can set it yourself using the &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setrlimit.html&quot;&gt;&lt;code&gt;setrlimit(2)&lt;/code&gt;&lt;/a&gt; system call. Here’s proof it works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat -n test-stack.c
     1  #include &amp;lt;errno.h&amp;gt;
     2  #include &amp;lt;stdio.h&amp;gt;
     3  #include &amp;lt;sys/resource.h&amp;gt;
     4
     5  #define BUF_SIZE (16*1024*1024)
     6
     7  void run(void) {
     8      char buf[BUF_SIZE];
     9      printf(&quot;%lu\n&quot;, sizeof(buf));
    10  }
    11
    12  int main(void) {
    13      struct rlimit stack_limit = {
    14          .rlim_cur = 2 * BUF_SIZE,
    15          .rlim_max = RLIM_INFINITY,
    16      };
    17
    18      if (setrlimit(RLIMIT_STACK, &amp;amp;stack_limit)) {
    19          perror(&quot;setrlimit failed&quot;);
    20          return 1;
    21      }
    22
    23      run();
    24
    25      return 0;
    26  }
$ gcc -Wall -Wextra -Werror test-stack.c
$ ulimit -Ss 8192
$ ./a.out
16777216
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A fun note: we had to put the buffer in a separate function. Otherwise the stack pointer would be adjusted before the call to &lt;code&gt;setrlimit&lt;/code&gt;, and then &lt;em&gt;that&lt;/em&gt; call would result in a segfault! This way the stack adjustment happens after calling &lt;code&gt;setrlimit&lt;/code&gt;, and everything works out.&lt;/p&gt;

&lt;p&gt;Allocating lots of stack space in main isn’t a great idea anyway, since you limit what’s available for the rest of your program. A static buffer would probably be better for this program; for others a heap buffer would work better.&lt;/p&gt;

&lt;h2 id=&quot;diving-into-the-depths-for-fun-and-learning&quot;&gt;diving into the depths for fun and learning&lt;/h2&gt;

&lt;p&gt;I had a fun hour or two investigating this. It’s not always possible to take the time in the moment, but it’s really rewarding when you can. I only vaguely knew about the &lt;code&gt;ulimit&lt;/code&gt; command, and didn’t know anything at all about &lt;code&gt;setrlimit(2)&lt;/code&gt;. Since I’ve been programming in languages that output native code a bunch lately, I’ve also wanted to learn more about object file formats, linkers, in-process memory layout, and more. Learning a bit more about stack guard pages is a great step in that direction!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;small&gt;&lt;em&gt;Thanks to Julia Evans for feedback on this post.&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:why-8-mb&quot;&gt;

      &lt;p&gt;Curiously, I found that if I had a buffer size of even 1 byte over (8 MB - 8 KB), I still got the segfault. I’m not yet sure what’s going on there! &lt;a href=&quot;#fnref:why-8-mb&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:why-rust-ok&quot;&gt;

      &lt;p&gt;Rust really likes to tout its memory safety. This seems like it should mean no segmentation faults, which is why I was confused at getting one. There’s &lt;a href=&quot;http://doc.rust-lang.org/reference.html#behavior-considered-undefined&quot;&gt;a very specific set of behaviors&lt;/a&gt; that aren’t allowed in Rust programs. The Rust program got a segmentation fault because it attempted to write to inaccessible memory, but only through the stack pointer. None of the undefined behaviors disallow this, which I think is why it’s ok for this Rust program to segfault. &lt;a href=&quot;#fnref:why-rust-ok&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:why-builtin&quot;&gt;

      &lt;p&gt;&lt;code&gt;ulimit&lt;/code&gt; must be a shell built-in and not an executable file because it sets a property of the shell’s process. Other fun examples include setting the working directory (&lt;code&gt;cd&lt;/code&gt;), and setting environment variables (&lt;code&gt;set -x&lt;/code&gt; in bash). These were some fun things I found out when &lt;a href=&quot;https://github.com/kamalmarhubi/shell-workshop&quot;&gt;building a shell&lt;/a&gt;, which is a totally worthwhile and fun exercise! &lt;a href=&quot;#fnref:why-builtin&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 25 Apr 2016 16:47:14 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/04/25/segfaults-are-our-friends-and-teachers/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/04/25/segfaults-are-our-friends-and-teachers/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 7</title>
        <description>&lt;p&gt;It’s been a month since the last update, which is definitely too long.
Here we go!&lt;/p&gt;

&lt;h2 id=&quot;projects-i-worked-since-last-update&quot;&gt;projects I worked since last update&lt;/h2&gt;

&lt;h3 id=&quot;cargo-fmt-diff&quot;&gt;cargo fmt-diff&lt;/h3&gt;

&lt;p&gt;After weeks of being “almost there”, I finally tidied up my initial work
into &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/pull/959&quot;&gt;a pull request&lt;/a&gt;! The pull request and commit
messages are good if you want to see details of what I did. The tl;dr is
that there is a &lt;code&gt;--experimental-file-lines&lt;/code&gt; flag that allows you to
specify &lt;code&gt;FILE:RANGE,RANGE,...&lt;/code&gt; to limit formatting to specific lines. It
only formats statements for now though!&lt;/p&gt;

&lt;p&gt;I had to do a bit of redesigning of my initial approach. I had been
assuming each run of the formatting function would affect only specific
files. However, by default it formats reachable files in the same crate.
This made me change the field on the configuration object from a set of
lines for a single file to a map from file names to line sets.&lt;/p&gt;

&lt;p&gt;There’s still some more refactoring work to put the line checks in the
right place, as well as making it handle more than just statements.
I wanted to get feedback on it before going further, since it’s already
a &lt;code&gt;+704 −131&lt;/code&gt; change. I was hoping it’d fall in at closer to &lt;code&gt;+400&lt;/code&gt; net.
Some of the surplus comes from including a few refactorings that &lt;em&gt;could&lt;/em&gt;
have been split out, but that I think make most sense in context of this
PR.&lt;/p&gt;

&lt;h3 id=&quot;silly-key-value-store&quot;&gt;silly key-value store&lt;/h3&gt;

&lt;p&gt;I did some experiments which resulted in the OOM killer going on a rampage
on my laptop. This was fun!&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;oh that was cool! I just got the OOM killer to kill stuff because I tried to fill 4GB of pipe buffers on system with 4GB RAM. still running!&lt;/p&gt;&amp;mdash; Kamal Marhubi (@kamalmarhubi) &lt;a href=&quot;https://twitter.com/kamalmarhubi/status/720386837953404928&quot;&gt;April 13, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;This is the project I’m expecting to work on most this week. There will
probably be a blog post or two as a result, and hopefully an exciting
update next time!&lt;/p&gt;

&lt;h2 id=&quot;projects-i-didnt-work-on&quot;&gt;projects I didn’t work on&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;tufcrates&lt;/li&gt;
  &lt;li&gt;containy-thing&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Apr 2016 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/04/25/100-10-1-update-7/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/04/25/100-10-1-update-7/</guid>
        
        
      </item>
    
      <item>
        <title>Rust + nix = easier unix systems programming &lt;3</title>
        <description>&lt;p&gt;Lately I’m writing lots of &lt;a href=&quot;https://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt;, and I’m particularly interested in systems programming on unix. I’ve been using and contributing to a library called &lt;a href=&quot;https://github.com/nix-rust/nix&quot;&gt;nix&lt;/a&gt;&lt;sup id=&quot;fnref:not-that-nix&quot;&gt;&lt;a href=&quot;#fn:not-that-nix&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, whose mission is to provide ‘Rust friendly bindings to *nix APIs’.&lt;/p&gt;

&lt;p&gt;In this blog post, I hope to convince you that you might want to reach for Rust and nix the next time you need to do some unix systems programming, especially if you aren’t fluent in C. It’s no harder to write, you won’t have to write more code, and it makes it much easier to avoid a few classes of mistakes.&lt;/p&gt;

&lt;h2 id=&quot;first-off-what-is-systems-programming&quot;&gt;First off, what is systems programming?&lt;/h2&gt;

&lt;p&gt;The term systems programming can mean all sorts of things, and depends a lot on context and who you’re talking to. For this blog post, here’s my incredibly precise definition:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Systems programming is programming where you spend more time reading man pages than reading the internet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(As an aside, this means that systems programming is programming you can happily do on the subway if you happen to be in one of those places that doesn’t have connectivity in the tunnels, like New York. I definitely did this when taking the Q train back from the &lt;a href=&quot;https://www.recurse.com/&quot;&gt;Recurse Center&lt;/a&gt; late at night!)&lt;/p&gt;

&lt;p&gt;Here are a few examples of things that fall under this definition:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;managing processes (eg, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html&quot;&gt;&lt;code&gt;fork(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;&lt;code&gt;execve(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/waitpid.html&quot;&gt;&lt;code&gt;waitpid(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/signal.html&quot;&gt;&lt;code&gt;signal(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html&quot;&gt;&lt;code&gt;kill(2)&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;working with files (eg, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html&quot;&gt;&lt;code&gt;open(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/ftruncate.html&quot;&gt;&lt;code&gt;ftruncate(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unlink.html&quot;&gt;&lt;code&gt;unlink(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html&quot;&gt;&lt;code&gt;read(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html&quot;&gt;&lt;code&gt;write(2)&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;network programming (eg, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html&quot;&gt;&lt;code&gt;socket(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setsockopt.html&quot;&gt;&lt;code&gt;setsockopt(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html&quot;&gt;&lt;code&gt;listen(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://man7.org/linux/man-pages/man2/sendfile.2.html&quot;&gt;&lt;code&gt;sendfile(2)&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;Linux containers (eg, &lt;a href=&quot;http://man7.org/linux/man-pages/man2/clone.2.html&quot;&gt;&lt;code&gt;clone(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://man7.org/linux/man-pages/man2/unshare.2.html&quot;&gt;&lt;code&gt;unshare(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://man7.org/linux/man-pages/man2/pivot_root.2.html&quot;&gt;&lt;code&gt;pivot_root(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://man7.org/linux/man-pages/man2/mount.2.html&quot;&gt;&lt;code&gt;mount(2)&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;interacting with hardware (eg, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/ioctl.html&quot;&gt;&lt;code&gt;ioctl(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html&quot;&gt;&lt;code&gt;mmap(2)&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;fork2-and-kill2-an-example-of-how-badly-things-can-go&quot;&gt;fork(2) and kill(2): an example of how badly things can go&lt;/h2&gt;

&lt;p&gt;Here’s a fairly innocuous looking C program that uses &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html&quot;&gt;&lt;code&gt;fork(2)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html&quot;&gt;&lt;code&gt;kill(2)&lt;/code&gt;&lt;/a&gt; to spawn and kill a process:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main(void) {
        pid_t child = fork();
        if (child) {  // in parent
                sleep(5);
                kill(child, SIGKILL);
        } else {  // in child
                for (;;);  // loop until killed
        }

        return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program compiles with no errors or warnings, not even with &lt;code&gt;-Wall -Wextra -Werror&lt;/code&gt;. I recommend you don’t run it though, and here’s why. From the POSIX specification for &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html&quot;&gt;&lt;code&gt;fork(2)&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Upon successful completion, fork() shall return 0 to the child process and shall return the process ID of the child process to the parent process. Both processes shall continue to execute from the fork() function. Otherwise, -1 shall be returned to the parent process, no child process shall be created, and errno shall be set to indicate the error.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And from the specification for &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html&quot;&gt;&lt;code&gt;kill(2)&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If pid is -1, &lt;strong&gt;sig shall be sent to all processes&lt;/strong&gt; (excluding an unspecified set of system processes) for which the process has permission to send that signal.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Putting the two together, that program could really ruin our day. If the &lt;code&gt;fork()&lt;/code&gt; call fails for some reason&lt;sup id=&quot;fnref:fork-failures&quot;&gt;&lt;a href=&quot;#fn:fork-failures&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;, we store &lt;code&gt;-1&lt;/code&gt; in &lt;code&gt;child&lt;/code&gt;. Later, we call &lt;code&gt;kill(-1, SIGKILL)&lt;/code&gt;, which tries to kill all our processes, and most likely hose our login. Not even &lt;code&gt;screen&lt;/code&gt; or &lt;code&gt;tmux&lt;/code&gt; will save us!&lt;sup id=&quot;fnref:rachel-fork-citation&quot;&gt;&lt;a href=&quot;#fn:rachel-fork-citation&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;It’s a pretty scary failure mode, and neither the library nor the language do anything at all to prevent us from having a terrible day.&lt;/p&gt;

&lt;h2 id=&quot;why-fork-and-kill-go-so-terribly-together&quot;&gt;Why fork and kill go so terribly together&lt;/h2&gt;

&lt;p&gt;I believe the main issue here is that the C library forces us to try and stick several meanings into one value. For &lt;code&gt;fork(2)&lt;/code&gt;, the return value is conveying &lt;em&gt;three&lt;/em&gt; different things all at once:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;whether or not the call succeeded (return value &lt;code&gt;-1&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;if it succeeded, whether or not we are in the child (return value &lt;code&gt;0&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;if we are the parent, what the child’s PID is (strictly positive return value)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That’s a lot of information for one poor little &lt;code&gt;pid_t&lt;/code&gt;—usually a 32-bit integer—to convey!&lt;/p&gt;

&lt;p&gt;In the case of &lt;code&gt;kill(2)&lt;/code&gt;, the &lt;code&gt;pid&lt;/code&gt; parameter conflates several different behaviors. From &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html#tag_16_286_03&quot;&gt;the POSIX specification&lt;/a&gt; again:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;If pid is greater than 0, sig shall be sent to the process whose process ID is equal to pid.&lt;/li&gt;
    &lt;li&gt;If pid is 0, sig shall be sent to all processes (excluding an unspecified set of system processes) whose process group ID is equal to the process group ID of the sender, and for which the process has permission to send a signal.&lt;/li&gt;
    &lt;li&gt;If pid is -1, sig shall be sent to all processes (excluding an unspecified set of system processes) for which the process has permission to send that signal.&lt;/li&gt;
    &lt;li&gt;If pid is negative, but not -1, sig shall be sent to all processes (excluding an unspecified set of system processes) whose process group ID is equal to the absolute value of pid, and for which the process has permission to send a signal.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Some extra badness comes from C’s way of treating all non-zero integral values as truthy in conditions, so our &lt;code&gt;if (child)&lt;/code&gt; check takes the true branch even when &lt;code&gt;fork()&lt;/code&gt; failed and returned &lt;code&gt;-1&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;The combination of &lt;code&gt;-1&lt;/code&gt; as failure value from &lt;code&gt;fork(2)&lt;/code&gt; and as a special value to &lt;code&gt;kill(2)&lt;/code&gt; is unfortunate and makes this example especially bad. But other functions treat a &lt;code&gt;pid&lt;/code&gt; value of &lt;code&gt;-1&lt;/code&gt; in a special way too, so even if we didn’t call &lt;code&gt;kill(2)&lt;/code&gt; this could still turn out badly. For example, if we called &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/waitpid.html&quot;&gt;&lt;code&gt;waitpid(2)&lt;/code&gt;&lt;/a&gt; instead, we’d end up either blocking execution waiting for termination of a child that doesn’t exist, or reaping a child that some other thread is waiting for. While they won’t ruin our system in quite the same way as &lt;code&gt;kill(-1, sig)&lt;/code&gt;, neither are failure modes that should be so easy to end up in!&lt;/p&gt;

&lt;h2 id=&quot;how-nix-and-rust-help-with-the-fork--kill-problem&quot;&gt;How nix and Rust help with the fork / kill problem&lt;/h2&gt;

&lt;p&gt;Here’s what this example would look like in Rust + nix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extern crate nix;

use nix::sys::signal::*;
use nix::unistd::*;

fn main() {
    match fork().expect(&quot;fork failed&quot;) {
        ForkResult::Parent{ child } =&amp;gt; {
            sleep(5);
            kill(child, SIGKILL).expect(&quot;kill failed&quot;);
        }
        ForkResult::Child =&amp;gt; {
            loop {}  // until killed
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We’ll go over it in detail below, but for now we’ll just notice that the structure and length are really similar to the C version. But it’s much safer, and won’t go on a process killing rampage!&lt;/p&gt;

&lt;p&gt;The nix wrapper for &lt;code&gt;fork(2)&lt;/code&gt; does two things to make it much easier to avoid accidentally killing all our processes. Both use &lt;a href=&quot;https://doc.rust-lang.org/stable/book/enums.html&quot;&gt;Rust’s enums&lt;/a&gt;, which are effectively tagged unions.&lt;/p&gt;

&lt;h3 id=&quot;separating-the-parent-and-child-returns-with-an-enum&quot;&gt;Separating the parent and child returns with an enum&lt;/h3&gt;

&lt;p&gt;For the success case, nix’s &lt;code&gt;fork()&lt;/code&gt; makes a really great use of a custom enum. Instead of returning just a plain &lt;code&gt;pid_t&lt;/code&gt;, it returns a &lt;code&gt;ForkResult&lt;/code&gt; type. The &lt;code&gt;ForkResult&lt;/code&gt; enum looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pub enum ForkResult {
    Parent {
        child: pid_t
    },
    Child
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can read this definition as saying that a &lt;code&gt;ForkResult&lt;/code&gt; is either &lt;code&gt;Parent&lt;/code&gt; or &lt;code&gt;Child&lt;/code&gt;. If it’s &lt;code&gt;Parent&lt;/code&gt; then it contains a &lt;code&gt;pid_t&lt;/code&gt; value named &lt;code&gt;child&lt;/code&gt;, while if it’s &lt;code&gt;Child&lt;/code&gt; then it contains no value. Rust has &lt;a href=&quot;https://doc.rust-lang.org/stable/book/match.html#matching-on-enums&quot;&gt;a pattern matching syntax&lt;/a&gt; for easily checking which variant an enum value is. If we have a variable &lt;code&gt;fork_result&lt;/code&gt;, we can pattern match on it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    match fork_result {
        ForkResult::Parent { child } =&amp;gt; {
            // stuff to do if we&#39;re in the parent
        }
        ForkResult::Child =&amp;gt; {
            // stuff do do if we&#39;re in the child
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;separating-the-success-and-failure-cases-with-result&quot;&gt;Separating the success and failure cases with Result&lt;/h3&gt;

&lt;p&gt;The other big thing Rust does to help is having a &lt;a href=&quot;http://doc.rust-lang.org/std/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type that’s used to represent the return from functions that can fail. Similar to how &lt;code&gt;ForkResult&lt;/code&gt; separated the parent and child cases, the built-in &lt;code&gt;Result&lt;/code&gt; type separates successes from failures. It looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#[must_use]
pub enum Result&amp;lt;T, E&amp;gt; {
    Ok(T),
    Err(E),
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can read this definition as saying that a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; is either &lt;code&gt;Ok&lt;/code&gt; to indicate success, or &lt;code&gt;Err&lt;/code&gt; to indicate failure. If it’s &lt;code&gt;Ok&lt;/code&gt;, it contains a &lt;code&gt;T&lt;/code&gt; value, while if it’s &lt;code&gt;Err&lt;/code&gt; it contains an &lt;code&gt;E&lt;/code&gt; value. For a specific case, you’d set &lt;code&gt;T&lt;/code&gt; to be the successful return type, and &lt;code&gt;E&lt;/code&gt; to be the type of error that can happen. And the &lt;code&gt;#[must_use]&lt;/code&gt; attribute tells the compiler to warn us if we ignore a &lt;code&gt;Result&lt;/code&gt; return value.&lt;sup id=&quot;fnref:compiler-warned&quot;&gt;&lt;a href=&quot;#fn:compiler-warned&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;For nix’s &lt;code&gt;fork()&lt;/code&gt; function, the return type is &lt;code&gt;Result&amp;lt;ForkResult, Errno&amp;gt;&lt;/code&gt;: our happy case is the &lt;code&gt;ForkResult&lt;/code&gt; type we talked about earlier. Our sad case is an &lt;code&gt;Errno&lt;/code&gt; value, which is simply an integer the OS uses to tell us why our call failed.&lt;/p&gt;

&lt;p&gt;We &lt;em&gt;could&lt;/em&gt; match on the return value of &lt;code&gt;fork()&lt;/code&gt; directly like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    match fork() {
        Ok(ForkResult::Parent { child }) =&amp;gt; {
            // stuff to do if we&#39;re in the parent
        }
        Ok(ForkResult::Child) =&amp;gt; {
            // stuff do do if we&#39;re in the child
        }
        Err(errno) =&amp;gt; {
            // stuff to do if there was an error
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, Rust has some idioms useful for dealing with &lt;code&gt;Result&lt;/code&gt; values that make code a little bit tidier. The one we’ll rely on in this post is &lt;a href=&quot;http://doc.rust-lang.org/std/result/enum.Result.html#method.expect&quot;&gt;&lt;code&gt;expect()&lt;/code&gt;&lt;/a&gt;. It unwraps the success value from an &lt;code&gt;Ok&lt;/code&gt; result, or panics with a given error message if called on an &lt;code&gt;Err&lt;/code&gt; result. It’s a handy way to just crash the program with a semi-useful error message when an error happens. That’s pretty much perfect for prototyping, or for quick and dirty programs.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;expect()&lt;/code&gt;, our match only has to consider the success cases:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    match fork().expect(&quot;fork failed&quot;) {
        ForkResult::Parent { child } =&amp;gt; {
            // stuff to do if we&#39;re in the parent
        }
        ForkResult::Child =&amp;gt; {
            // stuff do do if we&#39;re in the child
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;fork()&lt;/code&gt; failed, our program will exit with an error message that looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;thread &#39;&amp;lt;main&amp;gt;&#39; panicked at &#39;fork failed: ENOMEM&#39;, ../src/libcore/result.rs:709
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tells us what failed, and why. For our tiny program, that’s enough to see what went wrong. For a more complicated program, we could ask for a backtrace by setting &lt;code&gt;RUST_BACKTRACE=1&lt;/code&gt; in the environment.&lt;/p&gt;

&lt;p&gt;If you want to find out more about error handling in Rust, The Rust book has &lt;a href=&quot;https://doc.rust-lang.org/stable/book/error-handling.html&quot;&gt;a chapter&lt;/a&gt; with a fantastic and detailed look at different approaches. I highly recommend reading it!&lt;/p&gt;

&lt;h2 id=&quot;join-us&quot;&gt;Join us!&lt;/h2&gt;

&lt;p&gt;I’ve really been enjoying doing this kind of programming in Rust. So much that I became a maintainer for nix! We’ve been exploring a few ways of using Rust’s features to help make systems programming safer and easier to not mess up.&lt;/p&gt;

&lt;p&gt;If this kind of thing interests you too, come help out! We have &lt;a href=&quot;https://github.com/nix-rust/nix/issues?q=is%3Aissue+is%3Aopen+label%3AE-good-first-bug&quot;&gt;good first bug label&lt;/a&gt; on our issue tracker, as well as a &lt;a href=&quot;https://github.com/nix-rust/nix/issues?q=is%3Aissue+is%3Aopen+label%3AE-mentor&quot;&gt;mentored bug label&lt;/a&gt;. We’d love to have your input and your help!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;small&gt;&lt;em&gt;Thanks to Ant6n Dubrau, Bryan Newbold, Dan Luu, Julia Evans, and Mathieu Guay-Paquet for feedback on drafts of this post.&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:not-that-nix&quot;&gt;

      &lt;p&gt;Confusingly for some, the library has nothing to do with the &lt;a href=&quot;https://nixos.org/nix/&quot;&gt;Nix package manager&lt;/a&gt;, &lt;a href=&quot;https://nixos.org/&quot;&gt;NixOS&lt;/a&gt;, or any of the related projects. &lt;a href=&quot;#fnref:not-that-nix&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:fork-failures&quot;&gt;

      &lt;p&gt;There are two main ways &lt;code&gt;fork(2)&lt;/code&gt; can fail:&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;the system is out of memory&lt;/li&gt;
        &lt;li&gt;we’re at our process limit&lt;/li&gt;
      &lt;/ul&gt;

      &lt;p&gt;Either of these can happen, and code should be ready if they do! &lt;a href=&quot;#fnref:fork-failures&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:rachel-fork-citation&quot;&gt;

      &lt;p&gt;I first came across this issue in &lt;a href=&quot;http://rachelbythebay.com/w/2014/08/19/fork/&quot;&gt;a post on Rachel by the Bay&lt;/a&gt;—which incidentally is a great blog! &lt;a href=&quot;#fnref:rachel-fork-citation&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:compiler-warned&quot;&gt;

      &lt;p&gt;Fun fact: when I first wrote the example for this post, I forgot to check the return value from &lt;code&gt;kill()&lt;/code&gt;. Woops! But the compiler helpfully warned me that I was ignoring a &lt;code&gt;Result&lt;/code&gt; return value:&lt;/p&gt;

      &lt;pre&gt;&lt;code&gt;$ cargo build
   Compiling fork-rs v0.1.0 (file:///home/kamal/projects/talks/2016-03-24-rc/fork-rs)
src/main.rs:13:13: 13:34 warning: unused result which must be used, #[warn(unused_must_use)] on by default
src/main.rs:13             kill(child, SIGKILL);
                           ^~~~~~~~~~~~~~~~~~~~~
&lt;/code&gt;&lt;/pre&gt;
      &lt;p&gt;&lt;a href=&quot;#fnref:compiler-warned&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 13 Apr 2016 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/04/13/rust-nix-easier-unix-systems-programming-3/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/04/13/rust-nix-easier-unix-systems-programming-3/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 6</title>
        <description>&lt;p&gt;I said &lt;a href=&quot;/blog/2016/03/14/100-10-1-update-5/&quot;&gt;last time&lt;/a&gt; that I should keep a log; I didn’t. This is from
memory + what I could convince git and GitHub to tell me. Writing this also
makes me realize that now we’re two months into 100:10:1, I should promote some
more projects to round out my list of 10. I’ll try and make some progress there
this week!&lt;/p&gt;

&lt;h2 id=&quot;projects-i-worked-on-this-week&quot;&gt;projects I worked on this week&lt;/h2&gt;

&lt;h3 id=&quot;containy-thing&quot;&gt;containy-thing&lt;/h3&gt;

&lt;p&gt;I made some really minor changes to &lt;a href=&quot;https://github.com/kamalmarhubi/containy-thing&quot;&gt;containy-thing&lt;/a&gt;, which I haven’t pushed up
to GitHub yet. I switched to using the released version of &lt;a href=&quot;https://github.com/nix-rust/nix&quot;&gt;nix&lt;/a&gt; to pick up a
couple of changes I’d made to &lt;a href=&quot;https://github.com/nix-rust/nix/pull/231&quot;&gt;enable &lt;code&gt;mount(2)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://github.com/nix-rust/nix/pull/224&quot;&gt;make safe
wrappers for &lt;code&gt;getuid(2)&lt;/code&gt; and &lt;code&gt;getgid(2)&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is kind of cool because it’s popping some yaks off &lt;a href=&quot;/blog/2015/05/27/controlling-the-yak-stack/&quot;&gt;the yak
stack&lt;/a&gt;: I initially got involved with nix to make those changes.
Somehow I wound up making &lt;a href=&quot;https://github.com/nix-rust/nix/issues?utf8=%E2%9C%93&amp;amp;q=is%3Aissue+author%3Akamalmarhubi&quot;&gt;lots more&lt;/a&gt; &lt;a href=&quot;https://github.com/nix-rust/nix/commits?author=kamalmarhubi&quot;&gt;contributions&lt;/a&gt;,
and becoming a maintainer. It’s a fun circle, because I’m coming back to
containy-thing in order to get the CI for nix to run faster.&lt;/p&gt;

&lt;h3 id=&quot;silly-key-value-store&quot;&gt;silly key-value store&lt;/h3&gt;

&lt;p&gt;I did some initial work on this still-mysterious project. I’m pretty excited
for finally starting on it! Watch this space. :-)&lt;/p&gt;

&lt;h2 id=&quot;projects-i-didnt-work-on&quot;&gt;projects I didn’t work on&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;cargo fmt-diff&lt;/li&gt;
  &lt;li&gt;tufcrates&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 22 Mar 2016 14:06:52 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/03/22/100-10-1-update-6/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/03/22/100-10-1-update-6/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 5</title>
        <description>&lt;p&gt;I need to find a better way to track my time and know what I worked on. Here’s my recollection:&lt;/p&gt;

&lt;h1 id=&quot;cargo-fmt-diff&quot;&gt;cargo fmt-diff&lt;/h1&gt;

&lt;p&gt;I reached a great state on Saturday: I can pass a set of line ranges in on the
command line, and statements—but only statements—in that range will be
reformatted! I probably spent half an hour trying different sets of arguments
just to see it go. This is really exciting!&lt;/p&gt;

&lt;p&gt;I still need to tidy up the code and send in the PR, but I’m at point where the
infrastructure for this project is pretty much done. Next up is lots of
heuristics for figuring out what to do when a syntactic element is partially in
a modified line range. To get an idea: if you modify one line in a function
body, you don’t want to reformat the whole function. But if you modify one line
in a function declaration, you &lt;em&gt;may&lt;/em&gt; want to reformat the whole declaration.&lt;/p&gt;

&lt;h1 id=&quot;tufcrates&quot;&gt;tufcrates&lt;/h1&gt;

&lt;p&gt;I finally printed off &lt;a href=&quot;https://isis.poly.edu/%7Ejcappos/papers/kuppusamy_nsdi_16.pdf&quot;&gt;the latest paper&lt;/a&gt; from &lt;a href=&quot;http://theupdateframework.com/&quot;&gt;The Update
Framework&lt;/a&gt; folks. I’m about half way through it. The paper makes some
excellent extensions for community repositories, which is exactly what
&lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt; is. I’ll continue reading the paper this week, and aim
to write something about TUF and the problems it solves some time soon.&lt;/p&gt;

&lt;h1 id=&quot;rust-bisect&quot;&gt;rust-bisect&lt;/h1&gt;

&lt;p&gt;Someone on the Rust IRC channel gave me a bit of feedback on rust-bisect. This
was a) really exciting because someone was using my project, and b) really
useful as I now have some idea of what would be good to add next.&lt;/p&gt;

&lt;p&gt;Specifically, the immediate next step is to allow an interactive mode where you
can run commands with the nightly version instead of needing to write a script.
This would be analogous to the git-bisect without the &lt;code&gt;run&lt;/code&gt; subcommand. I may
end up changing the CLI to more closely match git-bisect in that case.&lt;/p&gt;

&lt;p&gt;There’s are open questions of how to track progress, and how to override he
user’s environment in the least intrusive and most friendly way. Current ideas
I have:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;have rust-bisect fork a shell with the environment set up so that &lt;code&gt;rustc&lt;/code&gt;,
  &lt;code&gt;cargo&lt;/code&gt;, et al will run the correct nightly version
    &lt;ul&gt;
      &lt;li&gt;pros:
        &lt;ul&gt;
          &lt;li&gt;easy to keep track of state in the parent process&lt;/li&gt;
          &lt;li&gt;immediate access in the shell, so they can run &lt;code&gt;rustc&lt;/code&gt; and &lt;code&gt;cargo&lt;/code&gt;
  without prefixing&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;cons:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;it’s not obvious how to communicate the outcome up to the parent process
from the shell: the obvious things involve terminating the shell and
forking a new one, but&lt;/li&gt;
          &lt;li&gt;I would most likely be overriding the user’s shell preference&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;store state in the filesystem, and require that they prefix commands with
  &lt;code&gt;rust-bisect run&lt;/code&gt; or a similar subcommand
    &lt;ul&gt;
      &lt;li&gt;pros:
        &lt;ul&gt;
          &lt;li&gt;easier to communicate the outcome, as there’s no environment overriding
going on&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;cons:
        &lt;ul&gt;
          &lt;li&gt;it’s unclear &lt;em&gt;where&lt;/em&gt; I should store the state. Current directory won’t
work, because they might go up and down the tree while testing. Home
directory might work, but would force at most one bisect at a time.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;something akin to what virtualenv does, providing a script to source that
  overrides the current shell’s environment.
    &lt;ul&gt;
      &lt;li&gt;pros:
        &lt;ul&gt;
          &lt;li&gt;it lets the user use their shell, and not prefix any commands&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;cons:
        &lt;ul&gt;
          &lt;li&gt;I don’t like it&lt;/li&gt;
          &lt;li&gt;I’d have to provide scripts for a couple of different shells&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I need to give this a bit more thought before implementing.&lt;/p&gt;

&lt;h1 id=&quot;projects-i-didnt-touch&quot;&gt;Projects I didn’t touch&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;containy-thing&lt;/li&gt;
  &lt;li&gt;silly key-value store&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 14 Mar 2016 11:59:21 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/03/14/100-10-1-update-5/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/03/14/100-10-1-update-5/</guid>
        
        
      </item>
    
      <item>
        <title>git rebase --exec: make sure your tests pass at each commit! (and other rebase goodies)</title>
        <description>&lt;p&gt;I learned about the &lt;code&gt;--exec&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; recently, and I needed to
share! The basic structure is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase --interactive --exec &quot;cmd&quot; some-ref
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This brings up the usual interactive rebase todo list, but with &lt;code&gt;exec &quot;cmd&quot;&lt;/code&gt;
added after each commit. Saving the todo list as-is will run &lt;code&gt;cmd&lt;/code&gt; at each
commit between &lt;code&gt;some-ref&lt;/code&gt; and the current &lt;code&gt;HEAD&lt;/code&gt;. You can use the short option
&lt;code&gt;-x&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase -ix &quot;cmd&quot; some-ref
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rebase will stop any time the &lt;code&gt;cmd&lt;/code&gt; exits unsuccessfully, giving you a
chance to inspect why it failed.&lt;/p&gt;

&lt;h2 id=&quot;making-sure-the-tests-always-pass&quot;&gt;making sure the tests always pass!&lt;/h2&gt;

&lt;p&gt;I like to have my pull requests broken up into small commits, eg one that does
a small refactor, one that adds a type, another that uses the new type. In the
run up to actually opening the pull request, I make lots of small
changes—style, documentation, comments, and so on.&lt;/p&gt;

&lt;p&gt;These finishing touches affect all the commits, so I do lots of little rebases.
There’s a risk of one of the intermediate commits being broken—not passing
tests, not building, having bad style or lint errors. If I was feeling extra
diligent, sometimes I’d manually step through the commits by marking them all
for &lt;code&gt;edit&lt;/code&gt; in &lt;code&gt;git rebase -i&lt;/code&gt;. But now it’s super easy to get right!&lt;/p&gt;

&lt;p&gt;You can even specify &lt;code&gt;--exec&lt;/code&gt; (&lt;code&gt;-x&lt;/code&gt;) multiple times, and all the commands will
get run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase -i -x &quot;run-tests&quot; -x &quot;run-linter&quot; master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;other-goodies-in-rebase&quot;&gt;other goodies in rebase&lt;/h2&gt;

&lt;p&gt;After finding out about &lt;code&gt;--exec&lt;/code&gt;, I wanted to be sure I wasn’t missing any
other life changing options or features, so here’s a quick tour of things I
discovered.&lt;/p&gt;

&lt;h3 id=&quot;the-options-in-the-rebase-todo-list&quot;&gt;the options in the rebase todo list&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;--exec&lt;/code&gt; option wouldn’t have surprised me if I ever looked at the options
that pop up in my editor &lt;em&gt;every time&lt;/em&gt; I use &lt;code&gt;git rebase -i&lt;/code&gt;! Here they are as
of git version 2.1.4, which is what I’m running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like &quot;squash&quot;, but discard this commit&#39;s log message
#  x, exec = run command (the rest of the line) using shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I don’t feel like I was missing out &lt;em&gt;too&lt;/em&gt; much though. I make good use of
&lt;code&gt;fixup&lt;/code&gt; and &lt;code&gt;reword&lt;/code&gt;, as well as the basics: &lt;code&gt;pick&lt;/code&gt;, &lt;code&gt;edit&lt;/code&gt;, and &lt;code&gt;squash&lt;/code&gt;.
&lt;code&gt;fixup&lt;/code&gt; is great if you make lots of little work-in-progress commits: you can
just squash them and throw away their messages. I find &lt;code&gt;reword&lt;/code&gt; is useful for
expanding on commit messages in the run up to opening a pull request.&lt;/p&gt;

&lt;h3 id=&quot;git-rebase---edit-todo&quot;&gt;git rebase –edit-todo&lt;/h3&gt;

&lt;p&gt;When you run &lt;code&gt;git rebase -i&lt;/code&gt;, your editor pops up with a list of commits for
you to mess with. I sometimes get my choices wrong, and end up doing &lt;code&gt;git
rebase --abort&lt;/code&gt; and starting over. It turns out I don’t need to! &lt;code&gt;git rebase
--edit-todo&lt;/code&gt; will bring up the same list and let you modify it.&lt;/p&gt;

&lt;h3 id=&quot;git-commit---squash---fixup-and-git-rebase---autosquash&quot;&gt;git commit –squash, –fixup, and git rebase –autosquash&lt;/h3&gt;

&lt;p&gt;I didn’t know about these at all, but I’m excited to try and get them into my
workflow! I’ll just quote the man page because it describes how to use them
very well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--autosquash, --no-autosquash
    When the commit log message begins with &quot;squash! ...&quot; (or &quot;fixup!
    ...&quot;), and there is a commit whose title begins with the same ...,
    automatically modify the todo list of rebase -i so that the commit
    marked for squashing comes right after the commit to be modified,
    and change the action of the moved commit from pick to squash (or
    fixup). Ignores subsequent &quot;fixup! &quot; or &quot;squash! &quot; after the first,
    in case you referred to an earlier fixup/squash with git commit
    --fixup/--squash.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;--squash&lt;/code&gt; and &lt;code&gt;--fixup&lt;/code&gt; options to &lt;code&gt;git commit&lt;/code&gt; take a commit as an
argument, and formats the commit message for use with &lt;code&gt;--autosquash&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To make it all even handier, you can set &lt;code&gt;rebase.autosquash&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in your
gitconfig. &lt;a href=&quot;https://github.com/kamalmarhubi/dotfiles-git/commit/dee6b4912c077bd06404937854ba053c16f8b880&quot;&gt;I just did&lt;/a&gt;!&lt;/p&gt;

&lt;h3 id=&quot;git-rebase---autostash&quot;&gt;git rebase –autostash&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;--autostash&lt;/code&gt; option will stash before starting a rebase, and pop the stash
afterwards. If you ever end up doing a dance like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git stash
git rebase -i master
git stash pop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the &lt;code&gt;--autostash&lt;/code&gt; option will save you 12 key presses each time. Or you
can set &lt;code&gt;rebase.autostash&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in your configuration, and it will happen
by default, saving you a whopping &lt;em&gt;24&lt;/em&gt; key presses!&lt;/p&gt;

&lt;p&gt;The man page warns that ‘the final stash application after a successful rebase
might result in non-trivial conflicts’, so I’ve not set this in my &lt;code&gt;gitconfig&lt;/code&gt;.
I’ll see how useful the option seems first.&lt;/p&gt;

&lt;h3 id=&quot;git-rebase---no-ff&quot;&gt;git rebase –no-ff&lt;/h3&gt;

&lt;p&gt;This forces the rebase to create new commits instead of fast-forwarding over
the unchanged ones. I’ve manually approximated this in the past to tickle the
continuous integration into running again if I think the failures were spurious
or flakes. This could be useful for repositories where you’re not the owner,
and so don’t have access to the CI system’s retry button.&lt;/p&gt;

&lt;h3 id=&quot;changing-the-merge-strategy&quot;&gt;changing the merge strategy&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;--strategy&lt;/code&gt; (&lt;code&gt;-s&lt;/code&gt;) option lets you say what merge strategy to use, and the
&lt;code&gt;--strategy-option&lt;/code&gt; (&lt;code&gt;-X&lt;/code&gt;) option lets you set options on the strategy. I just
figured out that, together with &lt;code&gt;--autosquash&lt;/code&gt;, this can let me do another
pre-pull-request-tidy task: making sure all the intermediate commits are
properly formatted.&lt;/p&gt;

&lt;p&gt;If you have some command &lt;code&gt;format-cmd&lt;/code&gt; that formats your code, then something
like this will format all the commits:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase -i \
-x &quot;format-cmd &amp;amp;&amp;amp; git commit -a --allow-empty --fixup=HEAD&quot; \
--strategy-option=theirs \
origin/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since I now have &lt;code&gt;rebase.autosquash&lt;/code&gt; set in my &lt;code&gt;gitconfig&lt;/code&gt;, this results in a
nice tidied up set of commits. I still have to tweak it a bit, as I had to &lt;code&gt;git
rebase --continue&lt;/code&gt; on an empty diff at some point, but it’s looking pretty
great! I will almost certainly turn it into an alias soon.&lt;/p&gt;

&lt;h2 id=&quot;sometimes-reading-docs-really-pays-off&quot;&gt;sometimes reading docs really pays off&lt;/h2&gt;

&lt;p&gt;I’m pretty happy with this exploration of &lt;code&gt;git rebase&lt;/code&gt;.  I’m pretty sure what I
just picked up here with &lt;code&gt;git rebase&lt;/code&gt; will make some things a &lt;em&gt;lot&lt;/em&gt; smoother in
the future. It makes me think I set aside a bit of time each week to read some
documentation for tools I use a lot. When I do, I’ll write it up!&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Mar 2016 14:38:55 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/03/08/git-rebase-exec-make-sure-your-tests-pass-at-each-commit-and-other-rebase-goodies/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/03/08/git-rebase-exec-make-sure-your-tests-pass-at-each-commit-and-other-rebase-goodies/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 4</title>
        <description>&lt;h1 id=&quot;rust-bisect&quot;&gt;rust-bisect&lt;/h1&gt;

&lt;p&gt;I &lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect/compare/3f2dbe0574ef9139817a5172c3134c62c2aa5f91...97324a58eba48d746b72f132fba0e3be0a9795a7&quot;&gt;spent some time&lt;/a&gt; getting TravisCI to build binary releases for
{Linux, OS X} × {i686, x86_64}. That makes it possible to use rust-bisect
without having a nightly build available to build with. This was mostly to get
around the annoyance of using a git dependency for multirust-rs, which pulled
hundreds of megabytes of useless binaries, and made the first build take a long
time.&lt;/p&gt;

&lt;p&gt;I later realized I could put the commit of multirust-rs I wanted in my
repository with &lt;code&gt;git subtree&lt;/code&gt;, &lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect/compare/97324a5...290b57c&quot;&gt;which I did&lt;/a&gt;. This at least
makes it easier to build. I just realized that it even makes it possible for me
to make a release on Crates.io, which I haven’t done yet.&lt;/p&gt;

&lt;h1 id=&quot;cargo-fmt-diff&quot;&gt;cargo fmt-diff&lt;/h1&gt;

&lt;p&gt;Not too much activity here. I think the main maintainer is on vacation, so my
first steps are still out for review. I made some changes to how the
conditionally included flag is conditionally included. I was using a
compile-time flag before, but I’ve changed to to always be compiled in, but only
available if an environment variable is set.&lt;/p&gt;

&lt;p&gt;This idea came out of a discussion of what the ‘integration’ in ‘continuous
integration’ means: changes are always integrated. I decided that having the
changes always compiled in was safer for when the feature is eventually
available by default.&lt;/p&gt;

</description>
        <pubDate>Sun, 06 Mar 2016 11:26:53 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/03/06/100-10-1-update-4/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/03/06/100-10-1-update-4/</guid>
        
        
      </item>
    
      <item>
        <title>My git aliases</title>
        <description>&lt;p&gt;&lt;small&gt;&lt;em&gt;This post has been &lt;a href=&quot;http://softdroid.net/moi-psevdonimy-v-git&quot;&gt;translated into Russian&lt;/a&gt;.&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;I have a few little aliases in &lt;a href=&quot;https://github.com/kamalmarhubi/dotfiles-git/blob/master/.gitconfig&quot;&gt;my &lt;code&gt;.gitconfig&lt;/code&gt;&lt;/a&gt; that I find useful
and that I thought I’d share.&lt;/p&gt;

&lt;h1 id=&quot;git-root-print-the-absolute-path-of-the-repository-root-directory&quot;&gt;git root: print the absolute path of the repository root directory&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# Print absolute path of repo root directory
root = rev-parse --show-toplevel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is useful in the shell if you end up &lt;code&gt;cd&lt;/code&gt;ed to somewhere deeper in the
repository but want to apply a command at the root, eg for a rename:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;somewhere/in/repo$ sed -i &#39;s/oldname/newname/g&#39; $(git root)/**
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;git-detach-get-to-a-detached-head-state-on-purpose&quot;&gt;git detach: get to a detached HEAD state on purpose&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# Get to a detached HEAD state on purpose! Usage: `git detach [REF]`
detach = !sh -c &#39;git checkout $(git rev-parse ${1:-HEAD})&#39; --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usually a detached HEAD state is something you don’t want to be in, but I’ve
wanted this in a few instances, so I added it as an alias. Eg, sometimes I want
to experiment but not actually create a branch. Running &lt;code&gt;git detach&lt;/code&gt; gives me a
‘branch’ I can make changes to, but without needing to name it, and without needing
to delete it afterwards. If it turns out I do want to save the work I did, I
can always &lt;code&gt;git checkout -b new-branch-name&lt;/code&gt;, or &lt;code&gt;git checkout old-branch-name
&amp;amp;&amp;amp; git merge --ff-only HEAD@{1}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This alias uses shell expansion by invoking &lt;code&gt;sh -c&lt;/code&gt;. The bang runs a shell
command, then &lt;code&gt;sh -c&lt;/code&gt; runs the rest through &lt;code&gt;sh&lt;/code&gt;. The final &lt;code&gt;--&lt;/code&gt; is necessary
to send any additional arguments to go to &lt;code&gt;git checkout&lt;/code&gt; rather than &lt;code&gt;sh&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;git-sha1-print-short-sha1-of-a-commit&quot;&gt;git sha1: print short sha1 of a commit&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# Print short sha1; usage: `git sha1 [REF]`
sha1 = !sh -c &#39;git rev-parse --short ${1:-HEAD}&#39; --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most often used with &lt;code&gt;xsel&lt;/code&gt; or &lt;code&gt;pbcopy&lt;/code&gt;, as in &lt;code&gt;git sha1 | xsel -i&lt;/code&gt; to copy the
current commit’s short sha1 to the clipboard.&lt;/p&gt;

&lt;p&gt;I use &lt;code&gt;sh -c&lt;/code&gt; for shell expansion again, though here it’s just for supplying a
default ref.&lt;/p&gt;

&lt;h1 id=&quot;git-gh-url-get-the-github-url-for-a-repository&quot;&gt;git gh-url: get the GitHub URL for a repository&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# Get the GitHub URL for a GitHub repository. Usage: `git gh-url [REMOTE]`
gh-url = &quot;!f() { \
	if ! remote=${1:-$(git config --get \
		branch.$(git symbolic-ref --short HEAD).remote)}; \
	then \
		echo no remote specified and could not get remote for HEAD; \
		exit; \
	fi; \
	if ! remote_url=$(git config --get remote.$remote.url); \
	then \
		echo &quot;could not get URL for remote \\`$remote\\`&quot;; \
		exit; \
	fi; \
	case $remote_url in \
		git@github.com:*.git) \
			repo=$(echo $remote_url \
				| sed &#39;s/git@github.com:\\(.*\\).git/\\1/&#39;);; \
		https://github.com/*) \
			repo=$(echo $remote_url \
				| sed &#39;s+https://github.com/\\(.*\\).git+\\1+&#39;);; \
		*) \
			echo &quot;\\`$remote\\` does not appear to have &quot; \
				&quot;a GitHub remote url: $remote_url&quot;; \
			exit 1;; \
	esac; \
	echo https://github.com/$repo; \
}; \
f&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This one is pretty self-explanatory in terms of usage, but it illustrates
another pattern of git aliases: defining shell function and immediately calling
it. The general pattern is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my-alias = &quot;!f() { \
	echo COMMANDS GO HERE, ESCAPING NEWLINES WITH \
		BACKSLASHES, AND TERMINATING WITH SEMICOLONS; \
}; \
f&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because we’re in a string inside a config file, there’s an annoying amount of
escaping necessary, but you get the hang of it fairly quickly.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Feb 2016 14:26:27 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/02/29/my-git-aliases/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/02/29/my-git-aliases/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 3</title>
        <description>&lt;p&gt;I’ve been neglecting the updates, but here we go! Since the last update, I got
a prototype out, but it was something that wasn’t on my list… I need to
figure out if it counts as one of the 10 or not :-)&lt;/p&gt;

&lt;h1 id=&quot;rust-bisect&quot;&gt;rust-bisect&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect&quot;&gt;rust-bisect&lt;/a&gt; is a little tool to help track down changes in Rust nightlies. It
works a lot like &lt;code&gt;git bisect run&lt;/code&gt;. You give it a command, a nightly build where
it succeeds, and a nightly build where it fails, and it does binary search to
find the first nightly where it fails.&lt;/p&gt;

&lt;h1 id=&quot;cargo-fmt-diff&quot;&gt;cargo fmt-diff&lt;/h1&gt;

&lt;p&gt;I’ve decided to give a name to the project formerly described as ‘rustfmt line
range &amp;amp; diff reading (format a patch)’: &lt;code&gt;cargo fmt-diff&lt;/code&gt;. It’ll be a command
you can run to format the lines you’ve changed. Ideally, you’ll be able to put
it in a VCS commit hook, and never introduce bad formatting. Think of it as a
style-oriented analogue of not rocket science:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;The Not Rocket Science Rule Of Software Engineering:&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;automatically maintain a repository of code that always passes all the tests&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;―&lt;a href=&quot;http://graydon2.dreamwidth.org/1597.html&quot;&gt;Graydon Hoare&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A (very!) rough plan of how I intend to get this done:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;add command line flag that takes a set of line ranges to format (progress:
&lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/issues/844&quot;&gt;rustfmt PR #844, ‘rustfmt: Add an ineffectual –file-lines flag behind a
feature’&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;parse a unified diff to get sets of line ranges to pass to the above flag&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you’re especially interested in this feature, the rustfmt issue to track is
&lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/issues/434&quot;&gt;#434&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;containy-thing-name-tbc&quot;&gt;containy-thing (name TBC)&lt;/h1&gt;

&lt;p&gt;I’m promoting a project I was working on over the holidays onto my list of 10:
containy-thing. It was formerly described as ‘container thing for running
commands in container context without privileges’, and I mentioned it in &lt;a href=&quot;http://kamalmarhubi.com/blog/2016/01/26/eat-your-greens-and-read-your-man-pages/&quot;&gt;Eat
your greens and read your man pages&lt;/a&gt; a month ago. The goal is to
allow running commands in a container environment without root privileges. I
just pushed up &lt;a href=&quot;https://github.com/kamalmarhubi/containy-thing&quot;&gt;a basic repository&lt;/a&gt; for it.&lt;/p&gt;

&lt;h1 id=&quot;rust-and-the-update-framework&quot;&gt;Rust and The Update Framework&lt;/h1&gt;

&lt;p&gt;I’m also promoting a fairly ambitious project onto the list of ten. In the list
of 100, it was cryptically described as ‘tuf + rust + crates’. The goal of this
project is to secure the Rust crate ecosystem using &lt;a href=&quot;http://theupdateframework.com/&quot;&gt;The Update Framework&lt;/a&gt;
(TUF). I’ve been interested in this project since well before I wrote any Rust.
Verifiable provenance of software artifacts is extremely important, and Rust
absolutely should have a good approach to it.&lt;/p&gt;

&lt;p&gt;The Update Framework is a really well-designed and well-thought out approach to
securing software updates and distribution. It’s being implemented for Python,
Docker, and other ecosystems. While I was in New York attending the Recurse
Center, I met up with the researchers behind TUF (&lt;a href=&quot;https://github.com/rust-lang/crates.io/issues/75#issuecomment-179904144&quot;&gt;minutes&lt;/a&gt;) to talk about
implementing it for Rust, but I hadn’t followed up until recently. The issue to
watch for this one is &lt;a href=&quot;https://github.com/rust-lang/crates.io/issues/75&quot;&gt;#75&lt;/a&gt; on the Crates.io repository.&lt;/p&gt;

&lt;p&gt;This project is really exciting, and more than a little bit scary because of
how important it is to get right. But I won’t be working on it alone, so that’s
great! The first steps are to refamiliarize myself with TUF, and then put
together a Rust RFC. The TUF folks have recently had &lt;a href=&quot;https://isis.poly.edu/~jcappos/papers/kuppusamy_nsdi_16.pdf&quot;&gt;a paper
accepted&lt;/a&gt; that describes how they have improved TUF even further,
and I’m starting with reading that.&lt;/p&gt;

&lt;h1 id=&quot;summary-of-the-list-of-ten&quot;&gt;Summary of the list-of-ten:&lt;/h1&gt;

&lt;p&gt;My list of ten now contains four projects:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cargo fmt-diff&lt;/li&gt;
  &lt;li&gt;containy-thing&lt;/li&gt;
  &lt;li&gt;silly memcached or redis-speaking key value store whose nature of silliness
is as yet undisclosed&lt;/li&gt;
  &lt;li&gt;TUF and Crates.io&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 29 Feb 2016 13:17:09 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/02/29/100-10-1-update-3/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/02/29/100-10-1-update-3/</guid>
        
        
      </item>
    
      <item>
        <title>rust-bisect: tracking down the Rust nightly that changed some behavior</title>
        <description>&lt;p&gt;After a bit more tinkering that expected, I’m finally (almost&lt;sup id=&quot;fnref:almost&quot;&gt;&lt;a href=&quot;#fn:almost&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;) releasing my first
Rust crate!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect&quot;&gt;rust-bisect&lt;/a&gt; helps track down when a change—usually a bug!—was
introduced into Rust. Rather than &lt;code&gt;git bisect&lt;/code&gt; directly on the Rust repository,
it uses nightly builds to speed up the process. This is faster in at least a
couple of ways:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;at over 100 pull requests merged per week, there are far more commits
to bisect than there are nightly builds&lt;/li&gt;
  &lt;li&gt;to run an individual test, all rust-bisect needs to do is download the
nightly: no slow Rust build at each step!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This was a really fun project to work on! I made a few changes to related
crates, and even had to solve a stereotypical &lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect/blob/master/src/bisect.rs&quot;&gt;algorithms interview
problem&lt;/a&gt;. And of course, there’s something extremely satisfying about
seeing it bisect and actually find the right nightly…&lt;/p&gt;

&lt;h1 id=&quot;try-it-out&quot;&gt;Try it out!&lt;/h1&gt;

&lt;p&gt;If you want to give it a shot, check out &lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect&quot;&gt;the repository&lt;/a&gt;—especially the
&lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect#example&quot;&gt;example&lt;/a&gt;!  I’d &lt;em&gt;really&lt;/em&gt; love to hear if this is useful to you. And please &lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect/issues&quot;&gt;open
issues&lt;/a&gt; if you come across any bugs!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:almost&quot;&gt;

      &lt;p&gt;It’s not on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; yet because it’s using some unreleased changes to
&lt;a href=&quot;https://github.com/Diggsey/multirust-rs&quot;&gt;multirust-rs&lt;/a&gt;… &lt;a href=&quot;https://github.com/Diggsey/multirust-rs/issues/54&quot;&gt;soon though&lt;/a&gt;! &lt;a href=&quot;#fnref:almost&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 23 Feb 2016 16:36:47 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/02/23/rust-bisect-tracking-down-the-rust-nightly-that-changed-some-behavior/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/02/23/rust-bisect-tracking-down-the-rust-nightly-that-changed-some-behavior/</guid>
        
        
      </item>
    
  </channel>
</rss>
