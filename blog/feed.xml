<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kamal Marhubi</title>
    <description></description>
    <link>http://kamalmarhubi.com/</link>
    <atom:link href="http://kamalmarhubi.com/blog/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 13 Apr 2016 22:42:21 -0400</pubDate>
    <lastBuildDate>Wed, 13 Apr 2016 22:42:21 -0400</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Rust + nix = easier unix systems programming &lt;3</title>
        <description>&lt;p&gt;Lately I’m writing lots of &lt;a href=&quot;https://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt;, and I’m particularly interested in systems programming on unix. I’ve been using and contributing to a library called &lt;a href=&quot;https://github.com/nix-rust/nix&quot;&gt;nix&lt;/a&gt;&lt;sup id=&quot;fnref:not-that-nix&quot;&gt;&lt;a href=&quot;#fn:not-that-nix&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, whose mission is to provide ‘Rust friendly bindings to *nix APIs’.&lt;/p&gt;

&lt;p&gt;In this blog post, I hope to convince you that you might want to reach for Rust and nix the next time you need to do some unix systems programming, especially if you aren’t fluent in C. It’s no harder to write, you won’t have to write more code, and it makes it much easier to avoid a few classes of mistakes.&lt;/p&gt;

&lt;h2 id=&quot;first-off-what-is-systems-programming&quot;&gt;First off, what is systems programming?&lt;/h2&gt;

&lt;p&gt;The term systems programming can mean all sorts of things, and depends a lot on context and who you’re talking to. For this blog post, here’s my incredibly precise definition:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Systems programming is programming where you spend more time reading man pages than reading the internet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(As an aside, this means that systems programming is programming you can happily do on the subway if you happen to be in one of those places that doesn’t have connectivity in the tunnels, like New York. I definitely did this when taking the Q train back from the &lt;a href=&quot;https://www.recurse.com/&quot;&gt;Recurse Center&lt;/a&gt; late at night!)&lt;/p&gt;

&lt;p&gt;Here are a few examples of things that fall under this definition:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;managing processes (eg, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html&quot;&gt;&lt;code&gt;fork(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;&lt;code&gt;execve(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/waitpid.html&quot;&gt;&lt;code&gt;waitpid(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/signal.html&quot;&gt;&lt;code&gt;signal(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html&quot;&gt;&lt;code&gt;kill(2)&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;working with files (eg, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html&quot;&gt;&lt;code&gt;open(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/ftruncate.html&quot;&gt;&lt;code&gt;ftruncate(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unlink.html&quot;&gt;&lt;code&gt;unlink(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html&quot;&gt;&lt;code&gt;read(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html&quot;&gt;&lt;code&gt;write(2)&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;network programming (eg, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html&quot;&gt;&lt;code&gt;socket(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setsockopt.html&quot;&gt;&lt;code&gt;setsockopt(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html&quot;&gt;&lt;code&gt;listen(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://man7.org/linux/man-pages/man2/sendfile.2.html&quot;&gt;&lt;code&gt;sendfile(2)&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;Linux containers (eg, &lt;a href=&quot;http://man7.org/linux/man-pages/man2/clone.2.html&quot;&gt;&lt;code&gt;clone(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://man7.org/linux/man-pages/man2/unshare.2.html&quot;&gt;&lt;code&gt;unshare(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://man7.org/linux/man-pages/man2/pivot_root.2.html&quot;&gt;&lt;code&gt;pivot_root(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://man7.org/linux/man-pages/man2/mount.2.html&quot;&gt;&lt;code&gt;mount(2)&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;interacting with hardware (eg, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/ioctl.html&quot;&gt;&lt;code&gt;ioctl(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html&quot;&gt;&lt;code&gt;mmap(2)&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;fork2-and-kill2-an-example-of-how-badly-things-can-go&quot;&gt;fork(2) and kill(2): an example of how badly things can go&lt;/h2&gt;

&lt;p&gt;Here’s a fairly innocuous looking C program that uses &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html&quot;&gt;&lt;code&gt;fork(2)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html&quot;&gt;&lt;code&gt;kill(2)&lt;/code&gt;&lt;/a&gt; to spawn and kill a process:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main(void) {
        pid_t child = fork();
        if (child) {  // in parent
                sleep(5);
                kill(child, SIGKILL);
        } else {  // in child
                for (;;);  // loop until killed
        }

        return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program compiles with no errors or warnings, not even with &lt;code&gt;-Wall -Wextra -Werror&lt;/code&gt;. I recommend you don’t run it though, and here’s why. From the POSIX specification for &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html&quot;&gt;&lt;code&gt;fork(2)&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Upon successful completion, fork() shall return 0 to the child process and shall return the process ID of the child process to the parent process. Both processes shall continue to execute from the fork() function. Otherwise, -1 shall be returned to the parent process, no child process shall be created, and errno shall be set to indicate the error.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And from the specification for &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html&quot;&gt;&lt;code&gt;kill(2)&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If pid is -1, &lt;strong&gt;sig shall be sent to all processes&lt;/strong&gt; (excluding an unspecified set of system processes) for which the process has permission to send that signal.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Putting the two together, that program could really ruin our day. If the &lt;code&gt;fork()&lt;/code&gt; call fails for some reason&lt;sup id=&quot;fnref:fork-failures&quot;&gt;&lt;a href=&quot;#fn:fork-failures&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;, we store &lt;code&gt;-1&lt;/code&gt; in &lt;code&gt;child&lt;/code&gt;. Later, we call &lt;code&gt;kill(-1, SIGKILL)&lt;/code&gt;, which tries to kill all our processes, and most likely hose our login. Not even &lt;code&gt;screen&lt;/code&gt; or &lt;code&gt;tmux&lt;/code&gt; will save us!&lt;sup id=&quot;fnref:rachel-fork-citation&quot;&gt;&lt;a href=&quot;#fn:rachel-fork-citation&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;It’s a pretty scary failure mode, and neither the library nor the language do anything at all to prevent us from having a terrible day.&lt;/p&gt;

&lt;h2 id=&quot;why-fork-and-kill-go-so-terribly-together&quot;&gt;Why fork and kill go so terribly together&lt;/h2&gt;

&lt;p&gt;I believe the main issue here is that the C library forces us to try and stick several meanings into one value. For &lt;code&gt;fork(2)&lt;/code&gt;, the return value is conveying &lt;em&gt;three&lt;/em&gt; different things all at once:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;whether or not the call succeeded (return value &lt;code&gt;-1&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;if it succeeded, whether or not we are in the child (return value &lt;code&gt;0&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;if we are the parent, what the child’s PID is (strictly positive return value)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That’s a lot of information for one poor little &lt;code&gt;pid_t&lt;/code&gt;—usually a 32-bit integer—to convey!&lt;/p&gt;

&lt;p&gt;In the case of &lt;code&gt;kill(2)&lt;/code&gt;, the &lt;code&gt;pid&lt;/code&gt; parameter conflates several different behaviors. From &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html#tag_16_286_03&quot;&gt;the POSIX specification&lt;/a&gt; again:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;If pid is greater than 0, sig shall be sent to the process whose process ID is equal to pid.&lt;/li&gt;
    &lt;li&gt;If pid is 0, sig shall be sent to all processes (excluding an unspecified set of system processes) whose process group ID is equal to the process group ID of the sender, and for which the process has permission to send a signal.&lt;/li&gt;
    &lt;li&gt;If pid is -1, sig shall be sent to all processes (excluding an unspecified set of system processes) for which the process has permission to send that signal.&lt;/li&gt;
    &lt;li&gt;If pid is negative, but not -1, sig shall be sent to all processes (excluding an unspecified set of system processes) whose process group ID is equal to the absolute value of pid, and for which the process has permission to send a signal.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Some extra badness comes from C’s way of treating all non-zero integral values as truthy in conditions, so our &lt;code&gt;if (child)&lt;/code&gt; check takes the true branch even when &lt;code&gt;fork()&lt;/code&gt; failed and returned &lt;code&gt;-1&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;The combination of &lt;code&gt;-1&lt;/code&gt; as failure value from &lt;code&gt;fork(2)&lt;/code&gt; and as a special value to &lt;code&gt;kill(2)&lt;/code&gt; is unfortunate and makes this example especially bad. But other functions treat a &lt;code&gt;pid&lt;/code&gt; value of &lt;code&gt;-1&lt;/code&gt; in a special way too, so even if we didn’t call &lt;code&gt;kill(2)&lt;/code&gt; this could still turn out badly. For example, if we called &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/waitpid.html&quot;&gt;&lt;code&gt;waitpid(2)&lt;/code&gt;&lt;/a&gt; instead, we’d end up either blocking execution waiting for termination of a child that doesn’t exist, or reaping a child that some other thread is waiting for. While they won’t ruin our system in quite the same way as &lt;code&gt;kill(-1, sig)&lt;/code&gt;, neither are failure modes that should be so easy to end up in!&lt;/p&gt;

&lt;h2 id=&quot;how-nix-and-rust-help-with-the-fork--kill-problem&quot;&gt;How nix and Rust help with the fork / kill problem&lt;/h2&gt;

&lt;p&gt;Here’s what this example would look like in Rust + nix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extern crate nix;

use nix::sys::signal::*;
use nix::unistd::*;

fn main() {
    match fork().expect(&quot;fork failed&quot;) {
        ForkResult::Parent{ child } =&amp;gt; {
            sleep(5);
            kill(child, SIGKILL).expect(&quot;kill failed&quot;);
        }
        ForkResult::Child =&amp;gt; {
            loop {}  // until killed
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We’ll go over it in detail below, but for now we’ll just notice that the structure and length are really similar to the C version. But it’s much safer, and won’t go on a process killing rampage!&lt;/p&gt;

&lt;p&gt;The nix wrapper for &lt;code&gt;fork(2)&lt;/code&gt; does two things to make it much easier to avoid accidentally killing all our processes. Both use &lt;a href=&quot;https://doc.rust-lang.org/stable/book/enums.html&quot;&gt;Rust’s enums&lt;/a&gt;, which are effectively tagged unions.&lt;/p&gt;

&lt;h3 id=&quot;separating-the-parent-and-child-returns-with-an-enum&quot;&gt;Separating the parent and child returns with an enum&lt;/h3&gt;

&lt;p&gt;For the success case, nix’s &lt;code&gt;fork()&lt;/code&gt; makes a really great use of a custom enum. Instead of returning just a plain &lt;code&gt;pid_t&lt;/code&gt;, it returns a &lt;code&gt;ForkResult&lt;/code&gt; type. The &lt;code&gt;ForkResult&lt;/code&gt; enum looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pub enum ForkResult {
    Parent {
        child: pid_t
    },
    Child
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can read this definition as saying that a &lt;code&gt;ForkResult&lt;/code&gt; is either &lt;code&gt;Parent&lt;/code&gt; and has a &lt;code&gt;pid_t&lt;/code&gt; value called &lt;code&gt;child&lt;/code&gt;, or it’s &lt;code&gt;Child&lt;/code&gt;. Rust has &lt;a href=&quot;https://doc.rust-lang.org/stable/book/match.html#matching-on-enums&quot;&gt;a pattern matching syntax&lt;/a&gt; for easily checking which variant an enum value is. If we have a variable &lt;code&gt;fork_result&lt;/code&gt;, we can pattern match on it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    match fork_result {
        ForkResult::Parent { child } =&amp;gt; {
            // stuff to do if we&#39;re in the parent
        }
        ForkResult::Child =&amp;gt; {
            // stuff do do if we&#39;re in the child
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;separating-the-success-and-failure-cases-with-result&quot;&gt;Separating the success and failure cases with Result&lt;/h3&gt;

&lt;p&gt;The other big thing Rust does to help is having a &lt;code&gt;Result&lt;/code&gt; type that’s used to represent the return from functions that can fail. Similar to how &lt;code&gt;ForkResult&lt;/code&gt; separated the parent and child cases, the built-in &lt;code&gt;Result&lt;/code&gt; type separates successes from failures. It looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#[must_use]
pub enum Result&amp;lt;T, E&amp;gt; {
    Ok(T),
    Err(E),
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can read this definition as saying that as a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; is either &lt;code&gt;Ok&lt;/code&gt; and contains a &lt;code&gt;T&lt;/code&gt; value, or is &lt;code&gt;Err&lt;/code&gt; and contains an &lt;code&gt;E&lt;/code&gt; value. For a specific case, you’d set &lt;code&gt;T&lt;/code&gt; to be the happy case type, and &lt;code&gt;E&lt;/code&gt; to be the type of error that can happen. And the &lt;code&gt;#[must_use]&lt;/code&gt; attribute tells the compiler to warn us if we ignore a &lt;code&gt;Result&lt;/code&gt; return value.&lt;sup id=&quot;fnref:compiler-warned&quot;&gt;&lt;a href=&quot;#fn:compiler-warned&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;For nix’s &lt;code&gt;fork()&lt;/code&gt; function, the return type is &lt;code&gt;Result&amp;lt;ForkResult, Errno&amp;gt;&lt;/code&gt;: our happy case is the &lt;code&gt;ForkResult&lt;/code&gt; type we talked about earlier. Our sad case is an &lt;code&gt;Errno&lt;/code&gt; value, which is simply an integer the OS uses to tell us why our call failed.&lt;/p&gt;

&lt;p&gt;We &lt;em&gt;could&lt;/em&gt; match on the return value of &lt;code&gt;fork()&lt;/code&gt; directly like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    match fork() {
        Ok(ForkResult::Parent { child }) =&amp;gt; {
            // stuff to do if we&#39;re in the parent
        }
        Ok(ForkResult::Child) =&amp;gt; {
            // stuff do do if we&#39;re in the child
        }
        Err(errno) =&amp;gt; {
            // stuff to do if there was an error
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, Rust has some idioms useful for dealing with &lt;code&gt;Result&lt;/code&gt; values that make code a little bit tidier. The one we’ll rely on in this post is &lt;a href=&quot;http://doc.rust-lang.org/std/result/enum.Result.html#method.expect&quot;&gt;&lt;code&gt;expect()&lt;/code&gt;&lt;/a&gt;. It unwraps the success value from an &lt;code&gt;Ok&lt;/code&gt; result, or panics with a given error message if called on an &lt;code&gt;Err&lt;/code&gt; result. It’s a handy way to just crash the program with a semi-useful error message when an error happens. That’s pretty much perfect for prototyping, or for quick and dirty programs.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;expect()&lt;/code&gt;, our match only has to consider the success cases:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    match fork().expect(&quot;fork failed&quot;) {
        ForkResult::Parent { child } =&amp;gt; {
            // stuff to do if we&#39;re in the parent
        }
        ForkResult::Child =&amp;gt; {
            // stuff do do if we&#39;re in the child
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;fork()&lt;/code&gt; failed, our program will exit with an error message that looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;thread &#39;&amp;lt;main&amp;gt;&#39; panicked at &#39;fork failed: ENOMEM&#39;, ../src/libcore/result.rs:709
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tells us what failed, and why. For our tiny program, that’s enough to see what went wrong. For a more complicated program, we could ask for a backtrace by setting &lt;code&gt;RUST_BACKTRACE=1&lt;/code&gt; in the environment.&lt;/p&gt;

&lt;p&gt;If you want to find out more about error handling in Rust, The Rust book has &lt;a href=&quot;https://doc.rust-lang.org/stable/book/error-handling.html&quot;&gt;a chapter&lt;/a&gt; with a fantastic and detailed look at different approaches. I highly recommend reading it!&lt;/p&gt;

&lt;h2 id=&quot;join-us&quot;&gt;Join us!&lt;/h2&gt;

&lt;p&gt;I’ve really been enjoying doing this kind of programming in Rust. So much that I became a maintainer for nix! We’ve been exploring a few ways of using Rust’s features to help make systems programming safer and easier to not mess up.&lt;/p&gt;

&lt;p&gt;If this kind of thing interests you too, come help out! We have &lt;a href=&quot;https://github.com/nix-rust/nix/issues?q=is%3Aissue+is%3Aopen+label%3AE-good-first-bug&quot;&gt;good first bug label&lt;/a&gt; on our issue tracker, as well as a &lt;a href=&quot;https://github.com/nix-rust/nix/issues?q=is%3Aissue+is%3Aopen+label%3AE-mentor&quot;&gt;mentored bug label&lt;/a&gt;. We’d love to have your input and your help!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;small&gt;&lt;em&gt;Thanks to Ant6n Dubrau, Dan Luu, Julia Evans, and Mathieu Guay-Paquet for feedback on drafts of this post.&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:not-that-nix&quot;&gt;

      &lt;p&gt;Confusingly for some, the library has nothing to do with the &lt;a href=&quot;https://nixos.org/nix/&quot;&gt;Nix package manager&lt;/a&gt;, &lt;a href=&quot;https://nixos.org/&quot;&gt;NixOS&lt;/a&gt;, or any of the related projects. &lt;a href=&quot;#fnref:not-that-nix&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:fork-failures&quot;&gt;

      &lt;p&gt;There are two main ways &lt;code&gt;fork(2)&lt;/code&gt; can fail:&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;the system is out of memory&lt;/li&gt;
        &lt;li&gt;we’re at our process limit&lt;/li&gt;
      &lt;/ul&gt;

      &lt;p&gt;Either of these can happen, and code should be ready if they do! &lt;a href=&quot;#fnref:fork-failures&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:rachel-fork-citation&quot;&gt;

      &lt;p&gt;I first came across this issue in &lt;a href=&quot;http://rachelbythebay.com/w/2014/08/19/fork/&quot;&gt;a post on Rachel by the Bay&lt;/a&gt;—which incidentally is a great blog! &lt;a href=&quot;#fnref:rachel-fork-citation&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:compiler-warned&quot;&gt;

      &lt;p&gt;Fun fact: when I first wrote the example for this post, I forgot to check the return value from &lt;code&gt;kill()&lt;/code&gt;. Woops! But the compiler helpfully warned me that I was ignoring a &lt;code&gt;Result&lt;/code&gt; return value:&lt;/p&gt;

      &lt;pre&gt;&lt;code&gt;$ cargo build
   Compiling fork-rs v0.1.0 (file:///home/kamal/projects/talks/2016-03-24-rc/fork-rs)
src/main.rs:13:13: 13:34 warning: unused result which must be used, #[warn(unused_must_use)] on by default
src/main.rs:13             kill(child, SIGKILL);
                           ^~~~~~~~~~~~~~~~~~~~~
&lt;/code&gt;&lt;/pre&gt;
      &lt;p&gt;&lt;a href=&quot;#fnref:compiler-warned&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 13 Apr 2016 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/04/13/rust-nix-easier-unix-systems-programming-3/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/04/13/rust-nix-easier-unix-systems-programming-3/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 6</title>
        <description>&lt;p&gt;I said &lt;a href=&quot;/blog/2016/03/14/100-10-1-update-5/&quot;&gt;last time&lt;/a&gt; that I should keep a log; I didn’t. This is from
memory + what I could convince git and GitHub to tell me. Writing this also
makes me realize that now we’re two months into 100:10:1, I should promote some
more projects to round out my list of 10. I’ll try and make some progress there
this week!&lt;/p&gt;

&lt;h2 id=&quot;projects-i-worked-on-this-week&quot;&gt;projects I worked on this week&lt;/h2&gt;

&lt;h3 id=&quot;containy-thing&quot;&gt;containy-thing&lt;/h3&gt;

&lt;p&gt;I made some really minor changes to &lt;a href=&quot;https://github.com/kamalmarhubi/containy-thing&quot;&gt;containy-thing&lt;/a&gt;, which I haven’t pushed up
to GitHub yet. I switched to using the released version of &lt;a href=&quot;https://github.com/nix-rust/nix&quot;&gt;nix&lt;/a&gt; to pick up a
couple of changes I’d made to &lt;a href=&quot;https://github.com/nix-rust/nix/pull/231&quot;&gt;enable &lt;code&gt;mount(2)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://github.com/nix-rust/nix/pull/224&quot;&gt;make safe
wrappers for &lt;code&gt;getuid(2)&lt;/code&gt; and &lt;code&gt;getgid(2)&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is kind of cool because it’s popping some yaks off &lt;a href=&quot;/blog/2015/05/27/controlling-the-yak-stack/&quot;&gt;the yak
stack&lt;/a&gt;: I initially got involved with nix to make those changes.
Somehow I wound up making &lt;a href=&quot;https://github.com/nix-rust/nix/issues?utf8=%E2%9C%93&amp;amp;q=is%3Aissue+author%3Akamalmarhubi&quot;&gt;lots more&lt;/a&gt; &lt;a href=&quot;https://github.com/nix-rust/nix/commits?author=kamalmarhubi&quot;&gt;contributions&lt;/a&gt;,
and becoming a maintainer. It’s a fun circle, because I’m coming back to
containy-thing in order to get the CI for nix to run faster.&lt;/p&gt;

&lt;h3 id=&quot;silly-key-value-store&quot;&gt;silly key-value store&lt;/h3&gt;

&lt;p&gt;I did some initial work on this still-mysterious project. I’m pretty excited
for finally starting on it! Watch this space. :-)&lt;/p&gt;

&lt;h2 id=&quot;projects-i-didnt-work-on&quot;&gt;projects I didn’t work on&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;cargo fmt-diff&lt;/li&gt;
  &lt;li&gt;tufcrates&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 22 Mar 2016 14:06:52 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/03/22/100-10-1-update-6/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/03/22/100-10-1-update-6/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 5</title>
        <description>&lt;p&gt;I need to find a better way to track my time and know what I worked on. Here’s my recollection:&lt;/p&gt;

&lt;h1 id=&quot;cargo-fmt-diff&quot;&gt;cargo fmt-diff&lt;/h1&gt;

&lt;p&gt;I reached a great state on Saturday: I can pass a set of line ranges in on the
command line, and statements—but only statements—in that range will be
reformatted! I probably spent half an hour trying different sets of arguments
just to see it go. This is really exciting!&lt;/p&gt;

&lt;p&gt;I still need to tidy up the code and send in the PR, but I’m at point where the
infrastructure for this project is pretty much done. Next up is lots of
heuristics for figuring out what to do when a syntactic element is partially in
a modified line range. To get an idea: if you modify one line in a function
body, you don’t want to reformat the whole function. But if you modify one line
in a function declaration, you &lt;em&gt;may&lt;/em&gt; want to reformat the whole declaration.&lt;/p&gt;

&lt;h1 id=&quot;tufcrates&quot;&gt;tufcrates&lt;/h1&gt;

&lt;p&gt;I finally printed off &lt;a href=&quot;https://isis.poly.edu/%7Ejcappos/papers/kuppusamy_nsdi_16.pdf&quot;&gt;the latest paper&lt;/a&gt; from &lt;a href=&quot;http://theupdateframework.com/&quot;&gt;The Update
Framework&lt;/a&gt; folks. I’m about half way through it. The paper makes some
excellent extensions for community repositories, which is exactly what
&lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt; is. I’ll continue reading the paper this week, and aim
to write something about TUF and the problems it solves some time soon.&lt;/p&gt;

&lt;h1 id=&quot;rust-bisect&quot;&gt;rust-bisect&lt;/h1&gt;

&lt;p&gt;Someone on the Rust IRC channel gave me a bit of feedback on rust-bisect. This
was a) really exciting because someone was using my project, and b) really
useful as I now have some idea of what would be good to add next.&lt;/p&gt;

&lt;p&gt;Specifically, the immediate next step is to allow an interactive mode where you
can run commands with the nightly version instead of needing to write a script.
This would be analogous to the git-bisect without the &lt;code&gt;run&lt;/code&gt; subcommand. I may
end up changing the CLI to more closely match git-bisect in that case.&lt;/p&gt;

&lt;p&gt;There’s are open questions of how to track progress, and how to override he
user’s environment in the least intrusive and most friendly way. Current ideas
I have:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;have rust-bisect fork a shell with the environment set up so that &lt;code&gt;rustc&lt;/code&gt;,
  &lt;code&gt;cargo&lt;/code&gt;, et al will run the correct nightly version
    &lt;ul&gt;
      &lt;li&gt;pros:
        &lt;ul&gt;
          &lt;li&gt;easy to keep track of state in the parent process&lt;/li&gt;
          &lt;li&gt;immediate access in the shell, so they can run &lt;code&gt;rustc&lt;/code&gt; and &lt;code&gt;cargo&lt;/code&gt;
  without prefixing&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;cons:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;it’s not obvious how to communicate the outcome up to the parent process
from the shell: the obvious things involve terminating the shell and
forking a new one, but&lt;/li&gt;
          &lt;li&gt;I would most likely be overriding the user’s shell preference&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;store state in the filesystem, and require that they prefix commands with
  &lt;code&gt;rust-bisect run&lt;/code&gt; or a similar subcommand
    &lt;ul&gt;
      &lt;li&gt;pros:
        &lt;ul&gt;
          &lt;li&gt;easier to communicate the outcome, as there’s no environment overriding
going on&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;cons:
        &lt;ul&gt;
          &lt;li&gt;it’s unclear &lt;em&gt;where&lt;/em&gt; I should store the state. Current directory won’t
work, because they might go up and down the tree while testing. Home
directory might work, but would force at most one bisect at a time.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;something akin to what virtualenv does, providing a script to source that
  overrides the current shell’s environment.
    &lt;ul&gt;
      &lt;li&gt;pros:
        &lt;ul&gt;
          &lt;li&gt;it lets the user use their shell, and not prefix any commands&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;cons:
        &lt;ul&gt;
          &lt;li&gt;I don’t like it&lt;/li&gt;
          &lt;li&gt;I’d have to provide scripts for a couple of different shells&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I need to give this a bit more thought before implementing.&lt;/p&gt;

&lt;h1 id=&quot;projects-i-didnt-touch&quot;&gt;Projects I didn’t touch&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;containy-thing&lt;/li&gt;
  &lt;li&gt;silly key-value store&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 14 Mar 2016 11:59:21 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/03/14/100-10-1-update-5/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/03/14/100-10-1-update-5/</guid>
        
        
      </item>
    
      <item>
        <title>git rebase --exec: make sure your tests pass at each commit! (and other rebase goodies)</title>
        <description>&lt;p&gt;I learned about the &lt;code&gt;--exec&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; recently, and I needed to
share! The basic structure is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase --interactive --exec &quot;cmd&quot; some-ref
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This brings up the usual interactive rebase todo list, but with &lt;code&gt;exec &quot;cmd&quot;&lt;/code&gt;
added after each commit. Saving the todo list as-is will run &lt;code&gt;cmd&lt;/code&gt; at each
commit between &lt;code&gt;some-ref&lt;/code&gt; and the current &lt;code&gt;HEAD&lt;/code&gt;. You can use the short option
&lt;code&gt;-x&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase -ix &quot;cmd&quot; some-ref
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rebase will stop any time the &lt;code&gt;cmd&lt;/code&gt; exits unsuccessfully, giving you a
chance to inspect why it failed.&lt;/p&gt;

&lt;h2 id=&quot;making-sure-the-tests-always-pass&quot;&gt;making sure the tests always pass!&lt;/h2&gt;

&lt;p&gt;I like to have my pull requests broken up into small commits, eg one that does
a small refactor, one that adds a type, another that uses the new type. In the
run up to actually opening the pull request, I make lots of small
changes—style, documentation, comments, and so on.&lt;/p&gt;

&lt;p&gt;These finishing touches affect all the commits, so I do lots of little rebases.
There’s a risk of one of the intermediate commits being broken—not passing
tests, not building, having bad style or lint errors. If I was feeling extra
diligent, sometimes I’d manually step through the commits by marking them all
for &lt;code&gt;edit&lt;/code&gt; in &lt;code&gt;git rebase -i&lt;/code&gt;. But now it’s super easy to get right!&lt;/p&gt;

&lt;p&gt;You can even specify &lt;code&gt;--exec&lt;/code&gt; (&lt;code&gt;-x&lt;/code&gt;) multiple times, and all the commands will
get run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase -i -x &quot;run-tests&quot; -x &quot;run-linter&quot; master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;other-goodies-in-rebase&quot;&gt;other goodies in rebase&lt;/h2&gt;

&lt;p&gt;After finding out about &lt;code&gt;--exec&lt;/code&gt;, I wanted to be sure I wasn’t missing any
other life changing options or features, so here’s a quick tour of things I
discovered.&lt;/p&gt;

&lt;h3 id=&quot;the-options-in-the-rebase-todo-list&quot;&gt;the options in the rebase todo list&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;--exec&lt;/code&gt; option wouldn’t have surprised me if I ever looked at the options
that pop up in my editor &lt;em&gt;every time&lt;/em&gt; I use &lt;code&gt;git rebase -i&lt;/code&gt;! Here they are as
of git version 2.1.4, which is what I’m running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like &quot;squash&quot;, but discard this commit&#39;s log message
#  x, exec = run command (the rest of the line) using shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I don’t feel like I was missing out &lt;em&gt;too&lt;/em&gt; much though. I make good use of
&lt;code&gt;fixup&lt;/code&gt; and &lt;code&gt;reword&lt;/code&gt;, as well as the basics: &lt;code&gt;pick&lt;/code&gt;, &lt;code&gt;edit&lt;/code&gt;, and &lt;code&gt;squash&lt;/code&gt;.
&lt;code&gt;fixup&lt;/code&gt; is great if you make lots of little work-in-progress commits: you can
just squash them and throw away their messages. I find &lt;code&gt;reword&lt;/code&gt; is useful for
expanding on commit messages in the run up to opening a pull request.&lt;/p&gt;

&lt;h3 id=&quot;git-rebase---edit-todo&quot;&gt;git rebase –edit-todo&lt;/h3&gt;

&lt;p&gt;When you run &lt;code&gt;git rebase -i&lt;/code&gt;, your editor pops up with a list of commits for
you to mess with. I sometimes get my choices wrong, and end up doing &lt;code&gt;git
rebase --abort&lt;/code&gt; and starting over. It turns out I don’t need to! &lt;code&gt;git rebase
--edit-todo&lt;/code&gt; will bring up the same list and let you modify it.&lt;/p&gt;

&lt;h3 id=&quot;git-commit---squash---fixup-and-git-rebase---autosquash&quot;&gt;git commit –squash, –fixup, and git rebase –autosquash&lt;/h3&gt;

&lt;p&gt;I didn’t know about these at all, but I’m excited to try and get them into my
workflow! I’ll just quote the man page because it describes how to use them
very well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--autosquash, --no-autosquash
    When the commit log message begins with &quot;squash! ...&quot; (or &quot;fixup!
    ...&quot;), and there is a commit whose title begins with the same ...,
    automatically modify the todo list of rebase -i so that the commit
    marked for squashing comes right after the commit to be modified,
    and change the action of the moved commit from pick to squash (or
    fixup). Ignores subsequent &quot;fixup! &quot; or &quot;squash! &quot; after the first,
    in case you referred to an earlier fixup/squash with git commit
    --fixup/--squash.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;--squash&lt;/code&gt; and &lt;code&gt;--fixup&lt;/code&gt; options to &lt;code&gt;git commit&lt;/code&gt; take a commit as an
argument, and formats the commit message for use with &lt;code&gt;--autosquash&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To make it all even handier, you can set &lt;code&gt;rebase.autosquash&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in your
gitconfig. &lt;a href=&quot;https://github.com/kamalmarhubi/dotfiles-git/commit/dee6b4912c077bd06404937854ba053c16f8b880&quot;&gt;I just did&lt;/a&gt;!&lt;/p&gt;

&lt;h3 id=&quot;git-rebase---autostash&quot;&gt;git rebase –autostash&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;--autostash&lt;/code&gt; option will stash before starting a rebase, and pop the stash
afterwards. If you ever end up doing a dance like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git stash
git rebase -i master
git stash pop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the &lt;code&gt;--autostash&lt;/code&gt; option will save you 12 key presses each time. Or you
can set &lt;code&gt;rebase.autostash&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in your configuration, and it will happen
by default, saving you a whopping &lt;em&gt;24&lt;/em&gt; key presses!&lt;/p&gt;

&lt;p&gt;The man page warns that ‘the final stash application after a successful rebase
might result in non-trivial conflicts’, so I’ve not set this in my &lt;code&gt;gitconfig&lt;/code&gt;.
I’ll see how useful the option seems first.&lt;/p&gt;

&lt;h3 id=&quot;git-rebase---no-ff&quot;&gt;git rebase –no-ff&lt;/h3&gt;

&lt;p&gt;This forces the rebase to create new commits instead of fast-forwarding over
the unchanged ones. I’ve manually approximated this in the past to tickle the
continuous integration into running again if I think the failures were spurious
or flakes. This could be useful for repositories where you’re not the owner,
and so don’t have access to the CI system’s retry button.&lt;/p&gt;

&lt;h3 id=&quot;changing-the-merge-strategy&quot;&gt;changing the merge strategy&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;--strategy&lt;/code&gt; (&lt;code&gt;-s&lt;/code&gt;) option lets you say what merge strategy to use, and the
&lt;code&gt;--strategy-option&lt;/code&gt; (&lt;code&gt;-X&lt;/code&gt;) option lets you set options on the strategy. I just
figured out that, together with &lt;code&gt;--autosquash&lt;/code&gt;, this can let me do another
pre-pull-request-tidy task: making sure all the intermediate commits are
properly formatted.&lt;/p&gt;

&lt;p&gt;If you have some command &lt;code&gt;format-cmd&lt;/code&gt; that formats your code, then something
like this will format all the commits:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase -i \
-x &quot;format-cmd &amp;amp;&amp;amp; git commit -a --allow-empty --fixup=HEAD&quot; \
--strategy-option=theirs \
origin/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since I now have &lt;code&gt;rebase.autosquash&lt;/code&gt; set in my &lt;code&gt;gitconfig&lt;/code&gt;, this results in a
nice tidied up set of commits. I still have to tweak it a bit, as I had to &lt;code&gt;git
rebase --continue&lt;/code&gt; on an empty diff at some point, but it’s looking pretty
great! I will almost certainly turn it into an alias soon.&lt;/p&gt;

&lt;h2 id=&quot;sometimes-reading-docs-really-pays-off&quot;&gt;sometimes reading docs really pays off&lt;/h2&gt;

&lt;p&gt;I’m pretty happy with this exploration of &lt;code&gt;git rebase&lt;/code&gt;.  I’m pretty sure what I
just picked up here with &lt;code&gt;git rebase&lt;/code&gt; will make some things a &lt;em&gt;lot&lt;/em&gt; smoother in
the future. It makes me think I set aside a bit of time each week to read some
documentation for tools I use a lot. When I do, I’ll write it up!&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Mar 2016 14:38:55 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/03/08/git-rebase-exec-make-sure-your-tests-pass-at-each-commit-and-other-rebase-goodies/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/03/08/git-rebase-exec-make-sure-your-tests-pass-at-each-commit-and-other-rebase-goodies/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 4</title>
        <description>&lt;h1 id=&quot;rust-bisect&quot;&gt;rust-bisect&lt;/h1&gt;

&lt;p&gt;I &lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect/compare/3f2dbe0574ef9139817a5172c3134c62c2aa5f91...97324a58eba48d746b72f132fba0e3be0a9795a7&quot;&gt;spent some time&lt;/a&gt; getting TravisCI to build binary releases for
{Linux, OS X} × {i686, x86_64}. That makes it possible to use rust-bisect
without having a nightly build available to build with. This was mostly to get
around the annoyance of using a git dependency for multirust-rs, which pulled
hundreds of megabytes of useless binaries, and made the first build take a long
time.&lt;/p&gt;

&lt;p&gt;I later realized I could put the commit of multirust-rs I wanted in my
repository with &lt;code&gt;git subtree&lt;/code&gt;, &lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect/compare/97324a5...290b57c&quot;&gt;which I did&lt;/a&gt;. This at least
makes it easier to build. I just realized that it even makes it possible for me
to make a release on Crates.io, which I haven’t done yet.&lt;/p&gt;

&lt;h1 id=&quot;cargo-fmt-diff&quot;&gt;cargo fmt-diff&lt;/h1&gt;

&lt;p&gt;Not too much activity here. I think the main maintainer is on vacation, so my
first steps are still out for review. I made some changes to how the
conditionally included flag is conditionally included. I was using a
compile-time flag before, but I’ve changed to to always be compiled in, but only
available if an environment variable is set.&lt;/p&gt;

&lt;p&gt;This idea came out of a discussion of what the ‘integration’ in ‘continuous
integration’ means: changes are always integrated. I decided that having the
changes always compiled in was safer for when the feature is eventually
available by default.&lt;/p&gt;

</description>
        <pubDate>Sun, 06 Mar 2016 11:26:53 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/03/06/100-10-1-update-4/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/03/06/100-10-1-update-4/</guid>
        
        
      </item>
    
      <item>
        <title>My git aliases</title>
        <description>&lt;p&gt;&lt;small&gt;&lt;em&gt;This post has been &lt;a href=&quot;http://softdroid.net/moi-psevdonimy-v-git&quot;&gt;translated into Russian&lt;/a&gt;.&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;I have a few little aliases in &lt;a href=&quot;https://github.com/kamalmarhubi/dotfiles-git/blob/master/.gitconfig&quot;&gt;my &lt;code&gt;.gitconfig&lt;/code&gt;&lt;/a&gt; that I find useful
and that I thought I’d share.&lt;/p&gt;

&lt;h1 id=&quot;git-root-print-the-absolute-path-of-the-repository-root-directory&quot;&gt;git root: print the absolute path of the repository root directory&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# Print absolute path of repo root directory
root = rev-parse --show-toplevel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is useful in the shell if you end up &lt;code&gt;cd&lt;/code&gt;ed to somewhere deeper in the
repository but want to apply a command at the root, eg for a rename:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;somewhere/in/repo$ sed -i &#39;s/oldname/newname/g&#39; $(git root)/**
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;git-detach-get-to-a-detached-head-state-on-purpose&quot;&gt;git detach: get to a detached HEAD state on purpose&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# Get to a detached HEAD state on purpose! Usage: `git detach [REF]`
detach = !sh -c &#39;git checkout $(git rev-parse ${1:-HEAD})&#39; --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usually a detached HEAD state is something you don’t want to be in, but I’ve
wanted this in a few instances, so I added it as an alias. Eg, sometimes I want
to experiment but not actually create a branch. Running &lt;code&gt;git detach&lt;/code&gt; gives me a
‘branch’ I can make changes to, but without needing to name it, and without needing
to delete it afterwards. If it turns out I do want to save the work I did, I
can always &lt;code&gt;git checkout -b new-branch-name&lt;/code&gt;, or &lt;code&gt;git checkout old-branch-name
&amp;amp;&amp;amp; git merge --ff-only HEAD@{1}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This alias uses shell expansion by invoking &lt;code&gt;sh -c&lt;/code&gt;. The bang runs a shell
command, then &lt;code&gt;sh -c&lt;/code&gt; runs the rest through &lt;code&gt;sh&lt;/code&gt;. The final &lt;code&gt;--&lt;/code&gt; is necessary
to send any additional arguments to go to &lt;code&gt;git checkout&lt;/code&gt; rather than &lt;code&gt;sh&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;git-sha1-print-short-sha1-of-a-commit&quot;&gt;git sha1: print short sha1 of a commit&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# Print short sha1; usage: `git sha1 [REF]`
sha1 = !sh -c &#39;git rev-parse --short ${1:-HEAD}&#39; --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most often used with &lt;code&gt;xsel&lt;/code&gt; or &lt;code&gt;pbcopy&lt;/code&gt;, as in &lt;code&gt;git sha1 | xsel -i&lt;/code&gt; to copy the
current commit’s short sha1 to the clipboard.&lt;/p&gt;

&lt;p&gt;I use &lt;code&gt;sh -c&lt;/code&gt; for shell expansion again, though here it’s just for supplying a
default ref.&lt;/p&gt;

&lt;h1 id=&quot;git-gh-url-get-the-github-url-for-a-repository&quot;&gt;git gh-url: get the GitHub URL for a repository&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# Get the GitHub URL for a GitHub repository. Usage: `git gh-url [REMOTE]`
gh-url = &quot;!f() { \
	if ! remote=${1:-$(git config --get \
		branch.$(git symbolic-ref --short HEAD).remote)}; \
	then \
		echo no remote specified and could not get remote for HEAD; \
		exit; \
	fi; \
	if ! remote_url=$(git config --get remote.$remote.url); \
	then \
		echo &quot;could not get URL for remote \\`$remote\\`&quot;; \
		exit; \
	fi; \
	case $remote_url in \
		git@github.com:*.git) \
			repo=$(echo $remote_url \
				| sed &#39;s/git@github.com:\\(.*\\).git/\\1/&#39;);; \
		https://github.com/*) \
			repo=$(echo $remote_url \
				| sed &#39;s+https://github.com/\\(.*\\).git+\\1+&#39;);; \
		*) \
			echo &quot;\\`$remote\\` does not appear to have &quot; \
				&quot;a GitHub remote url: $remote_url&quot;; \
			exit 1;; \
	esac; \
	echo https://github.com/$repo; \
}; \
f&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This one is pretty self-explanatory in terms of usage, but it illustrates
another pattern of git aliases: defining shell function and immediately calling
it. The general pattern is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my-alias = &quot;!f() { \
	echo COMMANDS GO HERE, ESCAPING NEWLINES WITH \
		BACKSLASHES, AND TERMINATING WITH SEMICOLONS; \
}; \
f&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because we’re in a string inside a config file, there’s an annoying amount of
escaping necessary, but you get the hang of it fairly quickly.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Feb 2016 14:26:27 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/02/29/my-git-aliases/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/02/29/my-git-aliases/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 3</title>
        <description>&lt;p&gt;I’ve been neglecting the updates, but here we go! Since the last update, I got
a prototype out, but it was something that wasn’t on my list… I need to
figure out if it counts as one of the 10 or not :-)&lt;/p&gt;

&lt;h1 id=&quot;rust-bisect&quot;&gt;rust-bisect&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect&quot;&gt;rust-bisect&lt;/a&gt; is a little tool to help track down changes in Rust nightlies. It
works a lot like &lt;code&gt;git bisect run&lt;/code&gt;. You give it a command, a nightly build where
it succeeds, and a nightly build where it fails, and it does binary search to
find the first nightly where it fails.&lt;/p&gt;

&lt;h1 id=&quot;cargo-fmt-diff&quot;&gt;cargo fmt-diff&lt;/h1&gt;

&lt;p&gt;I’ve decided to give a name to the project formerly described as ‘rustfmt line
range &amp;amp; diff reading (format a patch)’: &lt;code&gt;cargo fmt-diff&lt;/code&gt;. It’ll be a command
you can run to format the lines you’ve changed. Ideally, you’ll be able to put
it in a VCS commit hook, and never introduce bad formatting. Think of it as a
style-oriented analogue of not rocket science:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;The Not Rocket Science Rule Of Software Engineering:&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;automatically maintain a repository of code that always passes all the tests&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;―&lt;a href=&quot;http://graydon2.dreamwidth.org/1597.html&quot;&gt;Graydon Hoare&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A (very!) rough plan of how I intend to get this done:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;add command line flag that takes a set of line ranges to format (progress:
&lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/issues/844&quot;&gt;rustfmt PR #844, ‘rustfmt: Add an ineffectual –file-lines flag behind a
feature’&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;parse a unified diff to get sets of line ranges to pass to the above flag&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you’re especially interested in this feature, the rustfmt issue to track is
&lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/issues/434&quot;&gt;#434&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;containy-thing-name-tbc&quot;&gt;containy-thing (name TBC)&lt;/h1&gt;

&lt;p&gt;I’m promoting a project I was working on over the holidays onto my list of 10:
containy-thing. It was formerly described as ‘container thing for running
commands in container context without privileges’, and I mentioned it in &lt;a href=&quot;http://kamalmarhubi.com/blog/2016/01/26/eat-your-greens-and-read-your-man-pages/&quot;&gt;Eat
your greens and read your man pages&lt;/a&gt; a month ago. The goal is to
allow running commands in a container environment without root privileges. I
just pushed up &lt;a href=&quot;https://github.com/kamalmarhubi/containy-thing&quot;&gt;a basic repository&lt;/a&gt; for it.&lt;/p&gt;

&lt;h1 id=&quot;rust-and-the-update-framework&quot;&gt;Rust and The Update Framework&lt;/h1&gt;

&lt;p&gt;I’m also promoting a fairly ambitious project onto the list of ten. In the list
of 100, it was cryptically described as ‘tuf + rust + crates’. The goal of this
project is to secure the Rust crate ecosystem using &lt;a href=&quot;http://theupdateframework.com/&quot;&gt;The Update Framework&lt;/a&gt;
(TUF). I’ve been interested in this project since well before I wrote any Rust.
Verifiable provenance of software artifacts is extremely important, and Rust
absolutely should have a good approach to it.&lt;/p&gt;

&lt;p&gt;The Update Framework is a really well-designed and well-thought out approach to
securing software updates and distribution. It’s being implemented for Python,
Docker, and other ecosystems. While I was in New York attending the Recurse
Center, I met up with the researchers behind TUF (&lt;a href=&quot;https://github.com/rust-lang/crates.io/issues/75#issuecomment-179904144&quot;&gt;minutes&lt;/a&gt;) to talk about
implementing it for Rust, but I hadn’t followed up until recently. The issue to
watch for this one is &lt;a href=&quot;https://github.com/rust-lang/crates.io/issues/75&quot;&gt;#75&lt;/a&gt; on the Crates.io repository.&lt;/p&gt;

&lt;p&gt;This project is really exciting, and more than a little bit scary because of
how important it is to get right. But I won’t be working on it alone, so that’s
great! The first steps are to refamiliarize myself with TUF, and then put
together a Rust RFC. The TUF folks have recently had &lt;a href=&quot;https://isis.poly.edu/~jcappos/papers/kuppusamy_nsdi_16.pdf&quot;&gt;a paper
accepted&lt;/a&gt; that describes how they have improved TUF even further,
and I’m starting with reading that.&lt;/p&gt;

&lt;h1 id=&quot;summary-of-the-list-of-ten&quot;&gt;Summary of the list-of-ten:&lt;/h1&gt;

&lt;p&gt;My list of ten now contains four projects:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cargo fmt-diff&lt;/li&gt;
  &lt;li&gt;containy-thing&lt;/li&gt;
  &lt;li&gt;silly memcached or redis-speaking key value store whose nature of silliness
is as yet undisclosed&lt;/li&gt;
  &lt;li&gt;TUF and Crates.io&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 29 Feb 2016 13:17:09 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/02/29/100-10-1-update-3/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/02/29/100-10-1-update-3/</guid>
        
        
      </item>
    
      <item>
        <title>rust-bisect: tracking down the Rust nightly that changed some behavior</title>
        <description>&lt;p&gt;After a bit more tinkering that expected, I’m finally (almost&lt;sup id=&quot;fnref:almost&quot;&gt;&lt;a href=&quot;#fn:almost&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;) releasing my first
Rust crate!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect&quot;&gt;rust-bisect&lt;/a&gt; helps track down when a change—usually a bug!—was
introduced into Rust. Rather than &lt;code&gt;git bisect&lt;/code&gt; directly on the Rust repository,
it uses nightly builds to speed up the process. This is faster in at least a
couple of ways:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;at over 100 pull requests merged per week, there are far more commits
to bisect than there are nightly builds&lt;/li&gt;
  &lt;li&gt;to run an individual test, all rust-bisect needs to do is download the
nightly: no slow Rust build at each step!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This was a really fun project to work on! I made a few changes to related
crates, and even had to solve a stereotypical &lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect/blob/master/src/bisect.rs&quot;&gt;algorithms interview
problem&lt;/a&gt;. And of course, there’s something extremely satisfying about
seeing it bisect and actually find the right nightly…&lt;/p&gt;

&lt;h1 id=&quot;try-it-out&quot;&gt;Try it out!&lt;/h1&gt;

&lt;p&gt;If you want to give it a shot, check out &lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect&quot;&gt;the repository&lt;/a&gt;—especially the
&lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect#example&quot;&gt;example&lt;/a&gt;!  I’d &lt;em&gt;really&lt;/em&gt; love to hear if this is useful to you. And please &lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect/issues&quot;&gt;open
issues&lt;/a&gt; if you come across any bugs!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:almost&quot;&gt;

      &lt;p&gt;It’s not on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; yet because it’s using some unreleased changes to
&lt;a href=&quot;https://github.com/Diggsey/multirust-rs&quot;&gt;multirust-rs&lt;/a&gt;… &lt;a href=&quot;https://github.com/Diggsey/multirust-rs/issues/54&quot;&gt;soon though&lt;/a&gt;! &lt;a href=&quot;#fnref:almost&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 23 Feb 2016 16:36:47 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/02/23/rust-bisect-tracking-down-the-rust-nightly-that-changed-some-behavior/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/02/23/rust-bisect-tracking-down-the-rust-nightly-that-changed-some-behavior/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 2</title>
        <description>&lt;p&gt;I’m still being slow on picking the 10, but I’ve added a new one to the list. It
now stands at two items!&lt;/p&gt;

&lt;h2 id=&quot;a-very-silly-key-value-store&quot;&gt;A very silly key-value store&lt;/h2&gt;
&lt;p&gt;I’m really excited about the new idea. It’s a very silly key-value store. The
exact nature of the silliness will wait until I’m further along. I’ll make it
speak either the memcached or redis protocol—or both! This makes it fit under
one or both of these items from the &lt;a href=&quot;http://kamalmarhubi.com/blog/2016/01/25/100-10-1/&quot;&gt;original 100&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;memcached speaking thing&lt;/li&gt;
  &lt;li&gt;redis speaking thing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’ll be doing this in Rust—naturally. As a bit of preparation, I’ve already added
&lt;a href=&quot;https://github.com/rust-lang-nursery/libc/pull/170&quot;&gt;&lt;code&gt;sendfile(2)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/rust-lang-nursery/libc/pull/172&quot;&gt;&lt;code&gt;splice(2)&lt;/code&gt;, &lt;code&gt;tee(2)&lt;/code&gt;, and
&lt;code&gt;vmsplice(2)&lt;/code&gt;&lt;/a&gt; to the libc crate, and am working on adding them to
&lt;a href=&quot;https://github.com/carllerche/nix-rust&quot;&gt;nix&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once that’s done, I should be able to start on the silly part! :-)&lt;/p&gt;

&lt;h2 id=&quot;rustfmt-diff-formatting&quot;&gt;rustfmt diff formatting&lt;/h2&gt;
&lt;p&gt;I finally got &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/pull/812&quot;&gt;a pull request&lt;/a&gt; tidying up some config stuff
merged. This was neither my &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/pull/795&quot;&gt;first attempt&lt;/a&gt; nor my &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/pull/801&quot;&gt;second
attempt&lt;/a&gt;, but it got there eventually!&lt;/p&gt;

&lt;p&gt;I’ve exhausted what I’ve decided was some &lt;a href=&quot;http://composition.al/blog/2015/12/29/refactoring-as-a-way-to-understand-code/&quot;&gt;refactoring as a way to understand
code&lt;/a&gt;, but have not made a start on the actual task quite yet. I’m
working on a couple of other Rust developer infrastructure kinds of projects in
the meantime, but should get on with this one. I &lt;em&gt;really&lt;/em&gt; want to be able to
run &lt;code&gt;cargo fmt-diff&lt;/code&gt; or whatever the command ends up being.&lt;/p&gt;

</description>
        <pubDate>Tue, 09 Feb 2016 22:04:15 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/02/09/100-10-1-update-2/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/02/09/100-10-1-update-2/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 1</title>
        <description>&lt;p&gt;I’m going to try and write little updates as I work on &lt;a href=&quot;http://kamalmarhubi.com/blog/2016/01/25/100-10-1/&quot;&gt;100:10:1&lt;/a&gt;.
Here’s the first!&lt;/p&gt;

&lt;h1 id=&quot;picking-1-of-the-10&quot;&gt;Picking 1 of the 10&lt;/h1&gt;

&lt;p&gt;I haven’t made my short list of 10 prototypes quite yet, but I have picked one
of them. Loads of the projects I’m thinking of are in Rust, so I’m preemptively
shaving a yak and working on making the &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt&quot;&gt;rustfmt&lt;/a&gt; formatting tool work
incrementally. This was in the original list of 100 as&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;rustfmt line range &amp;amp; diff reading (format a patch)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Translating from Kamal-scribble-speak: make it so that rustfmt can format only a
specific set of lines. Then on top of that, make it format only the lines that
have changed according to a diff. This way you can always run rustfmt, safe in
the knowledge that it won’t be sticking all kinds of style changes across the
codebase along with your actual changes. It should even be possible to put it in
a pre-commit hook.&lt;/p&gt;

&lt;p&gt;I actually &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/issues/434&quot;&gt;filed an issue&lt;/a&gt; about this back in October, and even started
trying to work on it. It turns out it’s really hard to implement something
non-trivial in a codebase you’re unfamiliar with in a language you don’t know.&lt;/p&gt;

&lt;p&gt;But I’ve been doing some Rust since then, including working on &lt;a href=&quot;https://github.com/rust-lang/rust/pull/31056&quot;&gt;a patch to the
standard library&lt;/a&gt;. I’m way more fluent now, though there are still some
bits of the Rust library and type system I need to absorb further.&lt;/p&gt;

&lt;p&gt;Working myself up to the line ranges change, I’ve put &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/pulls?utf8=%E2%9C%93&amp;amp;q=is%3Apr+author%3Akamalmarhubi+created%3A2016-01-31..2016-02-02&quot;&gt;a bunch of improvements
out&lt;/a&gt;, mostly small. The big one was unifying the config object that
is passed through all parts of the formatting process. This will give me a place
to store the line ranges to be formatted. I’m waiting on &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/pull/801&quot;&gt;the
review&lt;/a&gt; for it:&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;tfw you want someone to review your code from 5 hours ago but they are in new zealand&lt;/p&gt;&amp;mdash; Kamal Marhubi (@kamalmarhubi) &lt;a href=&quot;https://twitter.com/kamalmarhubi/status/694639801765527552&quot;&gt;February 2, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;h1 id=&quot;up-next&quot;&gt;Up next&lt;/h1&gt;

&lt;p&gt;Actually implement the thing! I’ll probably write up some notes as I do this.
I’m pretty glad to have picked this project because it involves getting to know
a bit about how the Rust &lt;abbr title=&quot;abstract syntax tree&quot;&gt;AST&lt;/abbr&gt; is organized.&lt;/p&gt;

&lt;p&gt;rustfmt is an &lt;abbr title=&quot;abstract syntax tree&quot;&gt;AST&lt;/abbr&gt;-based formatter, rather than a token-based one. Instead of
moving bits of text around, it actually parses the entire program, and then
pretty prints it according to style rules. There’s &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/blob/master/Design.md&quot;&gt;a brief outline of the
design&lt;/a&gt; that’s pretty good if you want to read about it.&lt;/p&gt;

&lt;p&gt;For my change, the line ranges need to be translated to a set of &lt;abbr title=&quot;abstract syntax tree&quot;&gt;AST&lt;/abbr&gt; nodes, and
then selectively formatted. There will be some niggles around sets of lines that
straddle node boundaries which I’ll have to think about. And maybe even draw
some ‘pictures’!&lt;/p&gt;

</description>
        <pubDate>Tue, 02 Feb 2016 22:46:25 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/02/02/100-10-1-update-1/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/02/02/100-10-1-update-1/</guid>
        
        
      </item>
    
  </channel>
</rss>
