<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kamal Marhubi</title>
    <description></description>
    <link>http://kamalmarhubi.com/</link>
    <atom:link href="http://kamalmarhubi.com/blog/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 30 Jun 2015 02:12:44 -0400</pubDate>
    <lastBuildDate>Tue, 30 Jun 2015 02:12:44 -0400</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Recurse Center lab notes 2015-06-29: fun with signals; confusing shell-writing</title>
        <description>&lt;h1 id=&quot;signals&quot;&gt;Signals&lt;/h1&gt;

&lt;p&gt;I finished skimming the chapter on signals in &lt;a href=&quot;http://www.apuebook.com/about3e.html&quot;&gt;Advanced Programming in the UNIX
Environmnent&lt;/a&gt;. This took me a few attempts over the last few days, and I
fell asleep reading it at least once. One big takeaway for me was the
distinction between synchronous and asynchronous signals. In a nutshell:&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;strong&gt;synchronous signals&lt;/strong&gt;&lt;/dt&gt;
  &lt;dd&gt;these signals are a direct result of execution; examples include

    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;SIGFPE&lt;/code&gt; (stands for &lt;em&gt;f&lt;/em&gt;loating &lt;em&gt;p&lt;/em&gt;point &lt;em&gt;e&lt;/em&gt;xception), which is sent on
various errors in mathematical functions, such as dividing by zero&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;SIGPIPE&lt;/code&gt; (stands for… &lt;em&gt;pipe&lt;/em&gt;), which is sent if there’s a write to a pipe
with no readers&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;SIGSEGV&lt;/code&gt; (stands for &lt;em&gt;seg&lt;/em&gt;mentation &lt;em&gt;v&lt;/em&gt;iolation), which is sent
to a thread if it tries to access memory in a way it’s not allowed to, eg,
dereferencing a null pointer, reading read-protected memory like kernel memory&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;SIGBUS&lt;/code&gt; (&lt;em&gt;bus&lt;/em&gt; error, whatever that is meant to mean&lt;sup id=&quot;fnref:sigbus&quot;&gt;&lt;a href=&quot;#fn:sigbus&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;!), which is sent on
some types of memory access issues, eg, improper alignment, or—the one
that’s exciting to me—attempting to access memory mapped beyond the end of a
memory mapped file&lt;sup id=&quot;fnref:sigbus-openbsd&quot;&gt;&lt;a href=&quot;#fn:sigbus-openbsd&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;strong&gt;asynchronous signals&lt;/strong&gt;&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;these signals can get sent independently of the running process or thread;
they just show up. Examples include:
- &lt;code&gt;SIGINT&lt;/code&gt; (&lt;em&gt;interrupt&lt;/em&gt;), which is sent when you interrupt a process from the
  keyboard with &lt;code&gt;^C&lt;/code&gt; at the terminal
- &lt;code&gt;SIGKILL&lt;/code&gt;, which is sent when you &lt;code&gt;kill -9&lt;/code&gt; something to kill it with fire;
  the process terminates, and the signal cannot be caught, blocked or ignored
- &lt;code&gt;SIGSTOP&lt;/code&gt;, which is sent when you stop a process with &lt;code&gt;^Z&lt;/code&gt; at the terminal;
  the process is stopped, and will continue when it’s sent a &lt;code&gt;SIGCONT&lt;/code&gt;
  (&lt;em&gt;cont&lt;/em&gt;inue)
- &lt;code&gt;SIGHUP&lt;/code&gt; (&lt;em&gt;h&lt;/em&gt;ang&lt;em&gt;up&lt;/em&gt;), which is sent if the controlling terminal ‘hangs up’,
  ie, is closed—this one is a fun anachronism which serves to us that we’re
  still using &lt;a href=&quot;https://en.wikipedia.org/wiki/Terminal_emulator&quot;&gt;programs that pretend to be terminals&lt;/a&gt;,
  which are in turn mostly pretending to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Teleprinter&quot;&gt;teletype machines&lt;/a&gt;, and that
  everything sort of pretends to be connected over a phone line&lt;/p&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;h1 id=&quot;python-shell-writing-weirdness&quot;&gt;Python shell writing weirdness&lt;/h1&gt;

&lt;p&gt;Sophie asked me for some help with the mental model for file descriptors and
pipes and &lt;code&gt;dup2&lt;/code&gt; and what happens when you fork and other such fun things. There
is a really strange bug we couldn’t figure out: &lt;code&gt;ls | wc&lt;/code&gt; or &lt;code&gt;ls | head&lt;/code&gt; would
terminate as expected, but &lt;code&gt;yes | wc&lt;/code&gt; or &lt;code&gt;yes | head&lt;/code&gt; would not; &lt;code&gt;yes&lt;/code&gt; would
just keep on running and use loads of CPU, so it was not idle. On OS X only (2
machines tested). On Linux, it worked as expected, with &lt;code&gt;yes&lt;/code&gt; terminating and
complaining about the broken pipe. We gave up eventually, and I still haven’t
got any idea what’s wrong. I really wish &lt;a href=&quot;http://man7.org/linux/man-pages/man5/procfs.5.html&quot;&gt;&lt;code&gt;procfs&lt;/code&gt;&lt;/a&gt; existed on OS X!&lt;/p&gt;

&lt;p&gt;I wrote a minimized equivalent of our code. Please run it and let me know what
happens! On my machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://gist.githubusercontent.com/kamalmarhubi/65c2ea1063e479f0c16b/raw/2459725829891b156f61ec5fc808587846ec07be/pipe_weirdness.py &amp;gt; pipe_weirdness.py
$ chmod +x pipe_weirdness.py
$ ./pipe_weirdness yes head
y
y
y
y
y
y
y
y
y
y
yes: standard output: Broken pipe
yes: write error
$ █
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I’m really interested in ideas on why &lt;code&gt;yes&lt;/code&gt; wouldn’t terminate!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:sigbus&quot;&gt;

      &lt;p&gt;I think this is meant to be related to the memory bus, which makes sense for
unaligned accesses, but not for the memory mapped file situtuation. &lt;a href=&quot;#fnref:sigbus&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:sigbus-openbsd&quot;&gt;

      &lt;p&gt;From man pages and some experimentation, &lt;code&gt;SIGBUS&lt;/code&gt; is sent for this
situation on Linux, FreeBSD, OS X, and NetBSD; OpenBSD’s documentation says a
&lt;code&gt;SIGSEGV&lt;/code&gt; is sent instead. Feel free to &lt;a href=&quot;https://gist.github.com/kamalmarhubi/d8a3b3754bc2f4f62899&quot;&gt;test it out&lt;/a&gt; on your system! On mine:&lt;/p&gt;

      &lt;pre&gt;&lt;code&gt;$ curl https://gist.githubusercontent.com/kamalmarhubi/d8a3b3754bc2f4f62899/raw/333a1c8ebce4a3c7718e740ea4d175d22ca206fd/mmap_signal_test.c | cc -xc -o mmap_signal_test -
$ ./mmap_signal_test
Received signal while accessing 0x7facd3268000: Bus error
Going to ftruncate
Read: 0
Wrote and read: 1
$ █
&lt;/code&gt;&lt;/pre&gt;
      &lt;p&gt;&lt;a href=&quot;#fnref:sigbus-openbsd&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 29 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/29/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/29/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes 2015-06-24: playing with mmap</title>
        <description>&lt;p&gt;Today I wrote some code! None to show, just experiments. I’m investigating
&lt;code&gt;mmap&lt;/code&gt; and its interactions with &lt;code&gt;mprotect&lt;/code&gt; and &lt;code&gt;ftruncate&lt;/code&gt;. I got some good
responses to yesterday’s email thinking about approaches to a memory mapped
message builder for Cap’n Proto. In particular &lt;a href=&quot;https://groups.google.com/d/msg/capnproto/kLQOsxjkjxM/u8iNvbd6c6wJ&quot;&gt;a message from Paul
Pelzl&lt;/a&gt; expanded on my memory protection / &lt;code&gt;SIGSEGV&lt;/code&gt;-based idea
and suggested playing tricks with &lt;code&gt;MAP_FIXED&lt;/code&gt; to repeatedly remap the file as
it grows.&lt;/p&gt;

&lt;p&gt;I started doing some investigation to see what happens when you mix &lt;code&gt;mmap&lt;/code&gt;,
&lt;code&gt;mprotect&lt;/code&gt;, and &lt;code&gt;ftruncate&lt;/code&gt;. Here’s some stuff I found out:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;it is possible to create a non-zero length mapping with &lt;code&gt;mmap&lt;/code&gt; on a
zero-length file, eg, one just created by &lt;code&gt;touch&lt;/code&gt; for the purpose&lt;/li&gt;
  &lt;li&gt;on Linux, attempts to access any of the memory result in &lt;code&gt;SIGBUS&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;a &lt;code&gt;SIGBUS&lt;/code&gt; handler can call &lt;code&gt;ftruncate&lt;/code&gt; to extend the backing file; the
access will then succeed!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This suggests an even simpler approach than what emerged on the mailing list:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;mmap&lt;/code&gt; a huge amount of address space backed by the target file, which
starts off empty&lt;/li&gt;
  &lt;li&gt;allocate an initial segment of 4GB—the maximum in Cap’n Proto’s encoding&lt;/li&gt;
  &lt;li&gt;have a &lt;code&gt;SIGBUS&lt;/code&gt; handler call &lt;code&gt;ftruncate&lt;/code&gt; to extend the file whenever an
attempt is made to reach beyond the end&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;An initial page can be set aside for a segment table to allow compatibility
with the existing message readers. On closing of the file, the segment size can
be written in at whatever length was actually set aside on disk. There would
likely be an opportunity to shrink the segment down so it only occupies as much
space as was actually used; in this case the file could be truncated to that
size.&lt;/p&gt;

&lt;p&gt;This approach has a few nice features:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;it’s compatible with the existing flat array and stream based message readers&lt;/li&gt;
  &lt;li&gt;it does not require sparse file support&lt;/li&gt;
  &lt;li&gt;only one system call needs to be made in the signal handler&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I still need to do a bit more research. In particular, I’m wondering:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;will this work on non-Linux systems? The &lt;a href=&quot;http://man7.org/linux/man-pages/man2/mmap.2.html&quot;&gt;Linux &lt;code&gt;mmap&lt;/code&gt; manpage&lt;/a&gt;
mentions the &lt;code&gt;SIGBUS&lt;/code&gt; behaviour, as does &lt;a href=&quot;http://netbsd.gw.com/cgi-bin/man-cgi?mmap++NetBSD-current&quot;&gt;the NetBSD one&lt;/a&gt;, but
&lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=mmap&amp;amp;sektion=2&quot;&gt;the FreeBSD&lt;/a&gt; and &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man2/mmap.2.html&quot;&gt;OS X&lt;/a&gt; manpages do not; &lt;a href=&quot;http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man2/mmap.2?query=mmap&amp;amp;arch=i386&quot;&gt;OpenBSD’s
manpage&lt;/a&gt; says it will give a &lt;code&gt;SIGSEGV&lt;/code&gt; instead, and helpfully
points out that POSIX says this situation should be a &lt;code&gt;SIGBUS&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;how do I keep track of which regions belong to which files? The signal handler
has the address that called the fault, but I’ll have to have some way to look
it up.&lt;/li&gt;
  &lt;li&gt;how should the filis file lookup structure interact with threads? Is it a
global table for which we incur some synchronisation cost? Is it a
thread-local table, and we require that a message only be written to by the
creating thread?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’m hoping to answer at least the first question tomorrow, mostly for
curiosity’s sake. I’m happy to be Linux-only for now; I’m sure that if this
doesn’t work on other platforms, one of the other approaches will. After
testing this on someone’s Mac, I can start on a proof of concept message
builder, which will hopefully inform the design more.&lt;/p&gt;

</description>
        <pubDate>Wed, 24 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/24/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/24/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes 2015-06-23</title>
        <description>&lt;p&gt;My output today was to write &lt;a href=&quot;https://groups.google.com/d/msg/capnproto/kLQOsxjkjxM/ngbJYer52OwJ&quot;&gt;an email&lt;/a&gt;. I did a whole bunch of reading
up on memory mapped files and handling page faults to get to that point, so I
wasn’t exactly idle—just outputless. I need to remember that it still counts
and being productive, and making good use of time!&lt;/p&gt;

</description>
        <pubDate>Tue, 23 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/23/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/23/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes 2015-06-22</title>
        <description>&lt;p&gt;Today was slightly slow. I re-remembered why it’s a good idea to leave
things incomplete at the end of the day or week: it gives you somewhere
to start. I consider &lt;a href=&quot;https://github.com/kamalmarhubi/lsaddr&quot;&gt;&lt;code&gt;lsaddr&lt;/code&gt;&lt;/a&gt; to be more or less feature
complete at this point, at least for a ‘1.0’. That was the state on
Friday, and is still the state today. If something was left, I would
have had an immediate place to start this morning.&lt;/p&gt;

&lt;p&gt;I wasn’t feeling like going back to IPC benchmarking immediately, so I
ended up deciding to run a version of my &lt;a href=&quot;https://github.com/kamalmarhubi/shell-workshop&quot;&gt;Let’s Build a
Shell!&lt;/a&gt; workshop. I’ve been wanting to do this for a while,
since I think it’s a pretty good way to get a deeper understanding of
how our programs are run. I need to file some issues to improve the
documentation a little, but I remain pretty pleased with how it’s set
up. Good job past me!&lt;/p&gt;

&lt;p&gt;After the workshop, I spent a bit of time deciding what to do next. I
think I’ve settled on adding a memory mapped message builder to &lt;a href=&quot;https://capnproto.org/&quot;&gt;Cap’n
Proto&lt;/a&gt;’s C++ library. This was requested in a &lt;a href=&quot;https://groups.google.com/d/topic/capnproto/kLQOsxjkjxM/discussion&quot;&gt;recent mailing
list posting&lt;/a&gt;. It’ll get me poking at the innards of
Cap’n Proto a little, which would be good for one of my potential bigger
project ideas for my time at RC: a shared memory transport for &lt;a href=&quot;https://capnproto.org/rpc.html&quot;&gt;Cap’n
Proto RPC&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Mon, 22 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/22/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/22/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes 2015-06-18</title>
        <description>&lt;p&gt;Lots of progress on &lt;a href=&quot;https://github.com/kamalmarhubi/lsaddr&quot;&gt;&lt;code&gt;lsaddr&lt;/code&gt;&lt;/a&gt; today! Unlike yesterday, most of these
commits are writing code rather than poking at it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --since=yesterday --reverse --oneline
0a695b0 Get IPv6 addresses from /proc/net/if_inet6
683d9c2 Fix typo in Makefile
8d61702 Add debug target to Makefile
686995b Add --list-interfaces option
8f2d3c4 Sort output of --list-interfaces
db95d00 Comment why we replace colon with null
ccf04d5 Introduce struct str_list to remove need for triple pointers
2209807 Use struct str_list in struct args
99cc8db Check interfaces exist using entries from /proc/net/dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some highlights: I now feel like I’ve got this &lt;code&gt;lfind&lt;/code&gt; thing under control: I’m
using it to filter non-existent interfaces from the user’s arguments, as well
as to make sure I only output IP addresses for the specified interfaces. I also
implemented a &lt;code&gt;--list-interfaces&lt;/code&gt; option that does what it says. All this
information is pretty scattered and disorganised. Here are my sources:&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;code&gt;/proc/net/dev&lt;/code&gt;&lt;/dt&gt;
  &lt;dd&gt;contains a list of interfaces and some other data in a fairly
parse-unfriendly layout—two header rows, and the interface names have a colon
appended&lt;/dd&gt;
  &lt;dt&gt;&lt;code&gt;/proc/net/if_inet6&lt;/code&gt;&lt;/dt&gt;
  &lt;dd&gt;contains a list of IPv6 addresses along with some other data in a more
parse-friendly format, except that the IP addresses are given as 128-bits
hex-encoded, no colons and no zero-contractions—not ready for human
consumption&lt;/dd&gt;
  &lt;dt&gt;&lt;code&gt;ioctl(SIOCGIFCONF)&lt;/code&gt;&lt;/dt&gt;
  &lt;dd&gt;a system call that needs to be made on a socket file descriptor to get a list
of interfaces with IPv4 addresses as &lt;code&gt;struct sockaddr_in&lt;/code&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;So far &lt;code&gt;--include-loopback&lt;/code&gt; and &lt;code&gt;--include-link-local&lt;/code&gt; don’t do anything. I
started some refactoring to make them easier to impelment. I should be able to
get this wrapped up pretty soon!&lt;/p&gt;

&lt;p&gt;I also gave a presentation on writing manpages with &lt;a href=&quot;http://asciidoc.org/&quot;&gt;AsciiDoc&lt;/a&gt;. The tl;dr was
that it’s really easy! Take a look at the &lt;a href=&quot;https://github.com/kamalmarhubi/lsaddr/blob/master/lsaddr.1.txt&quot;&gt;AsciiDoc source&lt;/a&gt; for
the &lt;code&gt;lsaddr&lt;/code&gt; manpage. It starts off:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lsaddr(1)
=======

NAME
----
lsaddr - list active IP addresses

SYNOPSIS
--------
[verse]
*lsaddr* [ *-46* ] [*--include-loopback*] [*--include-ipv6-link-local*] [ _interface_ ... ]
*lsaddr --list-interfaces*

DESCRIPTION
-----------
List IP addresses of the specified __interface__s. By default, lists all IPv4
and IPv6 addresses, with the loopback interfaces and IPv6 link-local omitted.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here’s a screenshot of the formatted output in my terminal:
&lt;img src=&quot;/static/lsaddr-manpage.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;That’s it for now. I should be getting back to IPC stuff soon!&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/18/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/18/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes 2015-06-17</title>
        <description>&lt;p&gt;Not a lot to report today: I overslept and only got in at 11, and then left at
6 to go ringing. I did bring another recurser—Jess—along with me, so that was
cool. I think she’ll be back, too! I left ringing early to go and checkout the
&lt;a href=&quot;http://www.keyboard.io/&quot;&gt;Keyboardio Model 01&lt;/a&gt; in midtown. It’s a very attractive piece of
hardware, and has me tempted to order one. I’ll need a second keyboard at some
point, right?&lt;/p&gt;

&lt;p&gt;On the &lt;a href=&quot;https://github.com/kamalmarhubi/lsaddr&quot;&gt;&lt;code&gt;lsaddr&lt;/code&gt;&lt;/a&gt; front, I figured out how to make &lt;code&gt;lfind&lt;/code&gt; go. I don’t understand
why, but I’ll take my win for now. I’m also parsing &lt;code&gt;/proc/net/if_inet6&lt;/code&gt; to get
IPv6 addresses, though not yet including them in the output. I mostly pushed
characters around in source files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --since=yesterday --reverse --oneline
a08386b Fix typo in manpage
16fbff4 Change int to size_t in a couple of places
69300ac Use designated initializers instead of statements
614ef75 Rename ipv4_fd to sockfd and use AF_INET6
8d9aacc Check interface arguments exist
d21ecec Run clang-format
8f9fb9c Properly handle user specified interfaces
6d75545 Comment the repeated ioctl(SIOCGIFCONF)
3f03089 Improve handling of unspecified arguments
88a2eb5 Reformat struct initializer
8ea9224 Properly handle the IP version flags (IPv4 only)
bf08afa Move manpage doctype to a flag to a2x
cef15c4 Change manpage source file suffix to .1.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tomorrow’s work on &lt;code&gt;lsaddr&lt;/code&gt; will be to finish off IPv6 listing first thing in
the morning, and then do some restructuring to make option handling easier:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;get list of interfaces from /proc/net/dev
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;int list_interfaces(char ***interfaces, size_t *num_interfaces);&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;check against that list instead of using &lt;code&gt;ioctl&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;have a &lt;code&gt;struct address { char [ADDRESSBUFLEN] addr, char [IFNAMSIZ]
interface, enum {ipv4 = 4, ipv6 = 6} ip_version }&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;have an array of &lt;code&gt;struct address&lt;/code&gt; sorted by interface, version, addr&lt;/li&gt;
  &lt;li&gt;internal list of interfaces with pointers into list of &lt;code&gt;struct address&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other random things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I read &lt;a href=&quot;https://docs.google.com/document/pub?id=1IC9yOXj7j6cdLLxWEBAGRL6wl97tFxgjLUEHIX3MSTs&quot;&gt;Introducing the Journal&lt;/a&gt;, the post introducing &lt;code&gt;journald&lt;/code&gt;.
I’m new to this &lt;code&gt;systemd&lt;/code&gt; world so it was interesting to get some background.
The ‘frequently asked questions’ are pretty terrible though, in that
intending-to-be-funny-but-mostly-condescending way that’s a bit too common in
tech.&lt;/li&gt;
  &lt;li&gt;I went to yoga in the early afternoon, which was a good idea. I need to go
more often. Physical activity is good.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 17 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/17/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/17/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes 2015-06-16</title>
        <description>&lt;p&gt;Today I continued working on my &lt;code&gt;lsaddr&lt;/code&gt; utility for listing IP addresses.
Here’s a quick update:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;there is now a &lt;a href=&quot;https://github.com/kamalmarhubi/lsaddr&quot;&gt;repository on GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I have a &lt;a href=&quot;https://github.com/kamalmarhubi/lsaddr/blob/master/lsaddr.adoc&quot;&gt;man page&lt;/a&gt; that I’m mostly pleased with; here’s the
synopsis:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;
lsaddr [ -46 ] [--include-loopback] [--include-ipv6-link-local] [ interface ... ]
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;I am checking that the supplied interfaces exist and reporting errors with
&lt;a href=&quot;http://linux.die.net/man/3/error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt;, which I discovered was the done thing by using &lt;code&gt;ltrace&lt;/code&gt; on
&lt;code&gt;ls does-not-exist&lt;/code&gt; :-)&lt;/li&gt;
  &lt;li&gt;I tried to use &lt;a href=&quot;http://linux.die.net/man/3/lfind&quot;&gt;&lt;code&gt;lfind&lt;/code&gt;&lt;/a&gt; to determine if interfaces were listed as
arguments, but wow what a mess that was&lt;sup id=&quot;fnref:lfind-mess&quot;&gt;&lt;a href=&quot;#fn:lfind-mess&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;; I scrapped that to come
back to it another day&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In other news, I read &lt;a href=&quot;http://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html&quot;&gt;this exciting post&lt;/a&gt; by Brendan Gregg on eBPF
and tracing in the kernel. Apparently it will soon be possible to gather
latency data from inside the kernel. I haven’t figured out if this could be
interesting for IPC benchmarks.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:lfind-mess&quot;&gt;

      &lt;p&gt;the closest C comes to having generics / parametric polymorphism is
&lt;code&gt;void *&lt;/code&gt;. With things like &lt;a href=&quot;http://linux.die.net/man/3/malloc&quot;&gt;&lt;code&gt;malloc&lt;/code&gt;&lt;/a&gt;, this is mostly fine. With algorithms
like &lt;code&gt;lfind&lt;/code&gt; and friends… well you’re going to have a bad time. Just look
a this signature:&lt;/p&gt;

      &lt;p&gt;&lt;code&gt;
void *lfind(const void *key, const void *base, size_t *nmemb,
            size_t size, int(*compar)(const void *, const void *))
&lt;/code&gt;&lt;/p&gt;

      &lt;p&gt;I find &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find&quot;&gt;&lt;code&gt;std::find&lt;/code&gt;&lt;/a&gt; unfriendly, but this is a whole other level. &lt;a href=&quot;#fnref:lfind-mess&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 16 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/16/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/16/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes 2015-06-15: shipping, IPC, NUMA, AsciiDoc</title>
        <description>&lt;p&gt;Today I joined the ‘shipping’ checking group, instigated by &lt;a href=&quot;http://natwelch.com/&quot;&gt;Nat Welch&lt;/a&gt;.
The idea is to work towards actually shipping something, which I really want to
get better at while at RC.&lt;/p&gt;

&lt;p&gt;I decided on a simple utility to list IP addresses. This came out of my writing
on &lt;a href=&quot;/blog/2015/06/11/ifconfig-how-does-it-even/&quot;&gt;how &lt;code&gt;ifconfig&lt;/code&gt; works&lt;/a&gt;. &lt;a href=&quot;http://plover.com/~mjd/&quot;&gt;Mark Dominus&lt;/a&gt; said a
utility that just listed IP addresses would be handy, and he’s never come
across one. I did a little poking around the googles and stackoverflows, and
most answers involved &lt;code&gt;ifconfig&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, and either &lt;code&gt;sed&lt;/code&gt; or &lt;code&gt;awk&lt;/code&gt;. A few
listed the Linux only &lt;code&gt;ip addr show&lt;/code&gt; which still has a lot of cruft in its
output. I also came across another Linux only option, &lt;code&gt;hostname
--all-ip-addresses&lt;/code&gt;, which prints them one per line, ignoring loopback and link
local addresses.&lt;/p&gt;

&lt;p&gt;The last one is pretty close to what I would like, but it’s missing some handy
flags to specify IPv4 or IPv6, which interface, or whether to include link
local or loopback addresses. It’s also Linux only, which a standalone utility
could work around. I’m aiming to have a fairly polished first version for Linux
systems this week, possibly even dabbling in Debian packaging.&lt;/p&gt;

&lt;p&gt;Of course, right after deciding that, I got distracted following up on some
links &lt;a href=&quot;http://anil.recoil.org/&quot;&gt;Anil Madhavapeddy&lt;/a&gt; gave me last Thursday while he was at RC. It
turns out the IPC performance is of a lot of interest to virtualization people,
and he had this &lt;a href=&quot;https://github.com/avsm/ipc-bench&quot;&gt;big set of benchmarks&lt;/a&gt;. I also read through slides
from his FOSDEM 2012 talk entitled &lt;em&gt;The Wild West of UNIX I/O&lt;/em&gt;. This goes into
a lot of details around non-uniform memory architecture (NUMA) and how it
affects latency and throughput between core in a many core machine. It’s
incredibly fascinating that the interconnections between the cores can be
inferred from measuring IPC performance.&lt;/p&gt;

&lt;p&gt;Even more interesting to me was the little bit at the end on Fable I/O, an
‘ongoing attempt at a “new” sockets API for high-performance data’. Sadly, the
‘ongoing’ part of this no longer seems valid: the best I could find was a
&lt;a href=&quot;https://github.com/ms705/libfable&quot;&gt;&lt;code&gt;libfable&lt;/code&gt;&lt;/a&gt; repository that hasn’t seen any updates in a couple of
years. This got me a bit excited, and I started reading up a bit more on NUMA
support in Linux. I came across a &lt;a href=&quot;http://lwn.net/Articles/486858/&quot;&gt;&lt;em&gt;Linux Weekly News&lt;/em&gt; article&lt;/a&gt;
from 2012 on NUMA aware scheduling support. So many things to think about:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the idea of home NUMA nodes for processes&lt;/li&gt;
  &lt;li&gt;moving physical pages between nodes while leaving virtual addresses intact&lt;/li&gt;
  &lt;li&gt;grouping processes together into NUMA groups that will always share a home
node&lt;/li&gt;
  &lt;li&gt;the performance gains possible by understanding and exploiting hardware
details&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On the performance note, a quote from the LWN article stands out:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Without the NUMA balancing patches, over time, the benchmark ended up with
just as many remote memory accesses as local accesses - allocated memory was
spread across the system. With the NUMA balancer, 86% of the memory accesses
were local, leading to a significant speedup.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;NUMA: serious business.&lt;/p&gt;

&lt;p&gt;After a while I was able to settle down again from all this IPC excitement and
think about how to approach the list-IP-addresses utility. I decided to go with
some &lt;a href=&quot;http://tom.preston-werner.com/2010/08/23/readme-driven-development.html&quot;&gt;README-driven development&lt;/a&gt;, and drafted up a README. After a bit,
I changed the aim to writing a manpage. This was driven by a secret desire to
use &lt;a href=&quot;http://asciidoc.org/&quot;&gt;AsciiDoc&lt;/a&gt; (see also: &lt;a href=&quot;http://asciidoctor.org/&quot;&gt;AsciiDoctor&lt;/a&gt;), as I’ve been wanting to check it out as a Markdown alternative
for a while. I knew it had good support for manpage generation. In fact, the
&lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/&quot;&gt;&lt;code&gt;git&lt;/code&gt; docs&lt;/a&gt; are in AsciiDoc.&lt;/p&gt;

&lt;p&gt;So, current status:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I have some flags being parsed&lt;/li&gt;
  &lt;li&gt;can list IPv4 addresses&lt;/li&gt;
  &lt;li&gt;manpage needs some rewording and reworking&lt;/li&gt;
  &lt;li&gt;the tool needs a name. I had &lt;code&gt;lsip&lt;/code&gt;, after &lt;code&gt;lsof&lt;/code&gt;, but it looks wrong. I’m
now thinking &lt;code&gt;lsaddr&lt;/code&gt;. I am bad at names.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 15 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/15/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/15/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>ifconfig: how does it even?</title>
        <description>&lt;p&gt;I can already &lt;a href=&quot;/blog/2015/06/10/some-early-linux-ipc-latency-data/&quot;&gt;measure the latency&lt;/a&gt; of TCP sockets over the
loopback interface. I want to compare this to TCP sockets connecting to one of
the ‘real’ addresses the machine has, to see if it’s any different. I could see
this being either the same as the loopback interface, or being slower. I’m way
below the level I have any real knowledge of at this point, so there’s only one
way to find out.&lt;/p&gt;

&lt;p&gt;But rather than hardcode in the IP addresses, or take them on the command line,
I want the benchmark to find them itself. One thing I want out of these
benchmarks is for them to build on any Linux system, and run without needing
machine-specific arguments.  When &lt;em&gt;I&lt;/em&gt; find out what IP addresses my machine
has, I use &lt;code&gt;ifconfig&lt;/code&gt;. But how does &lt;code&gt;ifconfig&lt;/code&gt; do it? I was about to Google the
answer when I realised this would be a perfect time use &lt;code&gt;strace&lt;/code&gt;, and so I did!&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;I just straced ifconfig to find out how it finds out which interfaces exist! /cc &lt;a href=&quot;https://twitter.com/b0rk&quot;&gt;@b0rk&lt;/a&gt;&lt;/p&gt;&amp;mdash; Kamal Marhubi (@kamalmarhubi) &lt;a href=&quot;https://twitter.com/kamalmarhubi/status/608735834905415680&quot;&gt;June 10, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;Here’s the quick summary of what happens:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;create sockets of both &lt;code&gt;AF_INET&lt;/code&gt; and &lt;code&gt;AF_INET6&lt;/code&gt; families&lt;/li&gt;
  &lt;li&gt;read &lt;code&gt;/proc/net/dev&lt;/code&gt; to get a complete list of interfaces; we’ll need this
to get the addresses for &lt;code&gt;AF_INET6&lt;/code&gt; socket, as well as to get the list of
interfaces that don’t have an &lt;code&gt;AF_INET&lt;/code&gt; address&lt;/li&gt;
  &lt;li&gt;use the &lt;code&gt;SIOCGIFCONF&lt;/code&gt; &lt;code&gt;ioctl&lt;/code&gt; to get a list of addresses for &lt;code&gt;AF_INET&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;loop through the interface names that came from &lt;code&gt;/proc/net/dev&lt;/code&gt; and for each
one
    &lt;ul&gt;
      &lt;li&gt;read &lt;code&gt;/proc/net/if_inet6&lt;/code&gt; to get the IPv6 address for the interface, if
any&lt;/li&gt;
      &lt;li&gt;use a series of &lt;code&gt;ioctl&lt;/code&gt; calls to get data about the interface&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To see in more detail, take a look at &lt;a href=&quot;https://gist.github.com/kamalmarhubi/1dfc1fa302916e21975d&quot;&gt;this gist&lt;/a&gt; for an annotated
&lt;code&gt;strace&lt;/code&gt; of &lt;code&gt;ifconfig&lt;/code&gt; and &lt;code&gt;ifconfig -s&lt;/code&gt;.&lt;/p&gt;

</description>
        <pubDate>Thu, 11 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/11/ifconfig-how-does-it-even/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/11/ifconfig-how-does-it-even/</guid>
        
        
      </item>
    
      <item>
        <title>Some early Linux IPC latency data</title>
        <description>&lt;p&gt;I’ve &lt;a href=&quot;https://github.com/kamalmarhubi/linux-ipc-benchmarks/commit/e06c93b54b4d13e1f78c64add9ac8a5cdf19b9ff&quot;&gt;added&lt;/a&gt; &lt;a href=&quot;https://github.com/kamalmarhubi/linux-ipc-benchmarks/commit/8f9094522465db54003f08da4d5b797e2944f47e&quot;&gt;benchmarks&lt;/a&gt; for UNIX domain
sockets and TCP sockets over the loopback interface. UNIX domain sockets were
super easy to implement thanks to the handy &lt;a href=&quot;http://man7.org/linux/man-pages/man2/socketpair.2.html&quot;&gt;&lt;code&gt;socketpair&lt;/code&gt;&lt;/a&gt;
function. It was not really any different from pipes. The difference is that
since sockets are full duplex, you only need to create one pair.  If the
processes were unrelated, or if I wanted to be able to accept multiple
connections, it would be much more like TCP sockets—ie, a pain!&lt;/p&gt;

&lt;p&gt;I say a pain because, in doing this, I ‘found out’ that, despite having written
a non-zero number of server applications, I’ve never done socket programming
before. This wasn’t exactly a surprise, but it was definitely interesting to
realise how little I knew about how to go about it. Luckily, man pages! (And
&lt;a href=&quot;http://www.apuebook.com/index.html&quot;&gt;Advanced Programming in the UNIX Environment&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Here’s the quick tl;dr for TCP over IPv4::&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;to listen for incoming connections:
    &lt;ol&gt;
      &lt;li&gt;create a socket with &lt;code&gt;socket(AF_INET, SOCK_STREAM, 0 /* default protocol */)&lt;/code&gt;.&lt;sup id=&quot;fnref:default-proto&quot;&gt;&lt;a href=&quot;#fn:default-proto&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
      &lt;li&gt;bind it to a port with &lt;code&gt;bind(sockfd, addr, addrlen)&lt;/code&gt; where &lt;code&gt;addr&lt;/code&gt; is a
struct that specifies the address to bind to. For &lt;code&gt;AF_INET&lt;/code&gt;, this means
the IP and port. In my case, I used &lt;code&gt;INETADDR_LOOPBACK&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; to listen
on some available port on &lt;code&gt;127.0.0.1&lt;/code&gt;.&lt;sup id=&quot;fnref:htonl&quot;&gt;&lt;a href=&quot;#fn:htonl&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
      &lt;li&gt;start listening on the socket with &lt;code&gt;listen(sockfd, 1 /* backlog */)&lt;/code&gt;. I
used a &lt;code&gt;backlog&lt;/code&gt; of 1 because I only expect a single incoming connection.&lt;/li&gt;
      &lt;li&gt;finally, call &lt;code&gt;accept(sockfd, NULL /* addr */, NULL /* addrlen */)&lt;/code&gt; to
block until a connection comes in, which returns a new file descriptor to
talk to the connecting process. I pass in &lt;code&gt;NULL&lt;/code&gt; for the &lt;code&gt;addr&lt;/code&gt; because I
don’t care who’s talking to me!&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;to connect to another process that’s listening:
    &lt;ol&gt;
      &lt;li&gt;create a socket with &lt;code&gt;socket(AF_INET, SOCK_STREAM, 0 /* default protocol */)&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;connect to the remote process with &lt;code&gt;connect(sockfd, addr, addrlen)&lt;/code&gt;. The
&lt;code&gt;addr&lt;/code&gt; specifies the address to connect to; again for &lt;code&gt;AF_INET&lt;/code&gt; this means
the IP and port.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This brings me up to having programs to test latency for four IPC mechanisms:
- pipes
- eventfd
- UNIX domain sockets
- TCP sockets over the loopback interface&lt;/p&gt;

&lt;p&gt;Here is some early latency data from my machine, with emphasis on the tail latencies:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;50&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;75&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;90&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99.9&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99.99&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99.999&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pipes&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4255&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4960&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5208&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5352&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7814&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;16214&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;31290&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;eventfd&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4353&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4443&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4760&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5053&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9445&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;14573&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;68528&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;af_unix&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1439&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1621&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1655&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1898&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2681&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;11512&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;54714&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;af_inet_loopback&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7287&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7412&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7857&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;8573&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;17412&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;20515&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;37019&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Units are nanoseconds. Time is measured using &lt;code&gt;clock_gettime&lt;/code&gt; with
&lt;code&gt;CLOCK_MONOTONIC&lt;/code&gt;. The quantiles are for a million measurements; in all cases,
the binary was run with flags &lt;code&gt;--warmup-iters=10000 --iters=1 --repeat=1000000&lt;/code&gt;
(see below).&lt;/p&gt;

&lt;p&gt;For me, the biggest surprise was how much faster UNIX domain sockets were than
anything else, and in particular, how much faster they are than eventfd. Or
that they are faster at all. The &lt;code&gt;read&lt;/code&gt; call in each case blocks until a
corresponding &lt;code&gt;write&lt;/code&gt;. I would have thought eventfd had the minimal amount of
extra work beyond that, since all it does is read and modify a &lt;code&gt;uint64_t&lt;/code&gt;. In
fairness, each of the other programs are writing a single byte at present, but
I doubt the difference will be so drastic.&lt;/p&gt;

&lt;p&gt;Another fun thing is to see difference in `latency when pinning the two
processes to specific CPUs. My machine has a dual core processor, where each
processor has 2 hardware threads. Here’s a quick look at latencies for pipes
with different CPU affinities:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Percentile&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;50&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;75&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;90&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99.9&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99.99&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99.999&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;default&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4255&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4960&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5208&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5352&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7814&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;16214&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;31290&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;same CPU&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2386&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2402&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2564&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3134&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;12255&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;15126&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;28225&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;same core&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4232&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4270&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4395&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4788&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;14408&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;17101&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;39052&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;different core&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5043&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5101&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5170&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5772&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;11894&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;38726&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;398796&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I was expecting a difference between different cores and not, since it requires
a trip through the L3 cache. I have no realy idea of what difference I was
expecting, but a microsecond could make sense if multiple locations needed to
be accessed. This stuff is beyond my ken, so I’m just guessing.&lt;/p&gt;

&lt;p&gt;What I was &lt;em&gt;not&lt;/em&gt; expecting, was a dramatic difference between ‘same CPU’ and
‘same core’. The CPUs are hardware threads on a single core. I can’t think of
any reason there would be such a difference. I do want to check that it’s not
due to scheduling weirdness, so I’ll probably boot up in single user mode at
some point to give it another go.&lt;/p&gt;

&lt;p&gt;If you want to run these on your own system, clone the &lt;a href=&quot;https://github.com/kamalmarhubi/linux-ipc-benchmarks&quot;&gt;repo&lt;/a&gt; and run &lt;code&gt;make&lt;/code&gt;.
There will be four binaries produced, one for each of the mechanisms.  They all
take the same command line flags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  -c, --child-cpu=CPUID      CPU to run the child on; default is to let the
                             scheduler do as it will
  -i, -n, --iters=COUNT      number of iterations to measure; default: 100000
  -p, --parent-cpu=CPUID     CPU to run the parent on; default is to let the
                             scheduler do as it will
  -r, --repeat=COUNT         number of times to repeat measurement; default: 1
  -w, --warmup-iters=COUNT   number of iterations before measurement; default:
                             1000
  -?, --help                 Give this help list
      --usage                Give a short usage message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:default-proto&quot;&gt;

      &lt;p&gt;The default protocol for &lt;code&gt;SOCK_STREAM&lt;/code&gt; for the &lt;code&gt;AF_INET&lt;/code&gt;
socket family is TCP. &lt;a href=&quot;#fnref:default-proto&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:htonl&quot;&gt;

      &lt;p&gt;A fun little thing to be aware of is that the &lt;code&gt;addr&lt;/code&gt; must contain the IP
address in network byte order. This necessitates converting the IP address
and port using &lt;code&gt;htonl&lt;/code&gt; and &lt;code&gt;htons&lt;/code&gt;, respectively, to convert the IP from
&lt;em&gt;h_ost _to&lt;/em&gt; _n_etwork byte order (the &lt;code&gt;l&lt;/code&gt; stands for &lt;code&gt;long&lt;/code&gt;, which in this
case means a &lt;code&gt;uint32_t&lt;/code&gt; because &lt;code&gt;long&lt;/code&gt;s used to be shorter; the &lt;code&gt;s&lt;/code&gt; stands
for &lt;code&gt;short&lt;/code&gt; which have stayed short at 16 bits long). &lt;a href=&quot;#fnref:htonl&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/10/some-early-linux-ipc-latency-data/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/10/some-early-linux-ipc-latency-data/</guid>
        
        
      </item>
    
  </channel>
</rss>
