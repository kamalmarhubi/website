<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kamal Marhubi</title>
    <description></description>
    <link>http://kamalmarhubi.com/</link>
    <atom:link href="http://kamalmarhubi.com/blog/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 02 Mar 2016 13:22:51 -0500</pubDate>
    <lastBuildDate>Wed, 02 Mar 2016 13:22:51 -0500</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>My git aliases</title>
        <description>&lt;p&gt;I have a few little aliases in &lt;a href=&quot;https://github.com/kamalmarhubi/dotfiles-git/blob/master/.gitconfig&quot;&gt;my &lt;code&gt;.gitconfig&lt;/code&gt;&lt;/a&gt; that I find useful
and that I thought I’d share.&lt;/p&gt;

&lt;h1 id=&quot;git-root-print-the-absolute-path-of-the-repository-root-directory&quot;&gt;git root: print the absolute path of the repository root directory&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# Print absolute path of repo root directory
root = rev-parse --show-toplevel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is useful in the shell if you end up &lt;code&gt;cd&lt;/code&gt;ed to somewhere deeper in the
repository but want to apply a command at the root, eg for a rename:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;somewhere/in/repo$ sed -i &#39;s/oldname/newname/g&#39; $(git root)/**
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;git-detach-get-to-a-detached-head-state-on-purpose&quot;&gt;git detach: get to a detached HEAD state on purpose&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# Get to a detached HEAD state on purpose! Usage: `git detach [REF]`
detach = !sh -c &#39;git checkout $(git rev-parse ${1:-HEAD})&#39; --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usually a detached HEAD state is something you don’t want to be in, but I’ve
wanted this in a few instances, so I added it as an alias. Eg, sometimes I want
to experiment but not actually create a branch. Running &lt;code&gt;git detach&lt;/code&gt; gives me a
‘branch’ I can make changes to, but without needing to name it, and without needing
to delete it afterwards. If it turns out I do want to save the work I did, I
can always &lt;code&gt;git checkout -b new-branch-name&lt;/code&gt;, or &lt;code&gt;git checkout old-branch-name
&amp;amp;&amp;amp; git merge --ff-only HEAD@{1}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This alias uses shell expansion by invoking &lt;code&gt;sh -c&lt;/code&gt;. The bang runs a shell
command, then &lt;code&gt;sh -c&lt;/code&gt; runs the rest through &lt;code&gt;sh&lt;/code&gt;. The final &lt;code&gt;--&lt;/code&gt; is necessary
to send any additional arguments to go to &lt;code&gt;git checkout&lt;/code&gt; rather than &lt;code&gt;sh&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;git-sha1-print-short-sha1-of-a-commit&quot;&gt;git sha1: print short sha1 of a commit&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# Print short sha1; usage: `git sha1 [REF]`
sha1 = !sh -c &#39;git rev-parse --short ${1:-HEAD}&#39; --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most often used with &lt;code&gt;xsel&lt;/code&gt; or &lt;code&gt;pbcopy&lt;/code&gt;, as in &lt;code&gt;git sha1 | xsel -i&lt;/code&gt; to copy the
current commit’s short sha1 to the clipboard.&lt;/p&gt;

&lt;p&gt;I use &lt;code&gt;sh -c&lt;/code&gt; for shell expansion again, though here it’s just for supplying a
default ref.&lt;/p&gt;

&lt;h1 id=&quot;git-gh-url-get-the-github-url-for-a-repository&quot;&gt;git gh-url: get the GitHub URL for a repository&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# Get the GitHub URL for a GitHub repository. Usage: `git gh-url [REMOTE]`
gh-url = &quot;!f() { \
	if ! remote=${1:-$(git config --get \
		branch.$(git symbolic-ref --short HEAD).remote)}; \
	then \
		echo no remote specified and could not get remote for HEAD; \
		exit; \
	fi; \
	if ! remote_url=$(git config --get remote.$remote.url); \
	then \
		echo &quot;could not get URL for remote \\`$remote\\`&quot;; \
		exit; \
	fi; \
	case $remote_url in \
		git@github.com:*.git) \
			repo=$(echo $remote_url \
				| sed &#39;s/git@github.com:\\(.*\\).git/\\1/&#39;);; \
		https://github.com/*) \
			repo=$(echo $remote_url \
				| sed &#39;s+https://github.com/\\(.*\\).git+\\1+&#39;);; \
		*) \
			echo &quot;\\`$remote\\` does not appear to have &quot; \
				&quot;a GitHub remote url: $remote_url&quot;; \
			exit 1;; \
	esac; \
	echo https://github.com/$repo; \
}; \
f&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This one is pretty self-explanatory in terms of usage, but it illustrates
another pattern of git aliases: defining shell function and immediately calling
it. The general pattern is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my-alias = &quot;!f() { \
	echo COMMANDS GO HERE, ESCAPING NEWLINES WITH \
		BACKSLASHES, AND TERMINATING WITH SEMICOLONS; \
}; \
f&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because we’re in a string inside a config file, there’s an annoying amount of
escaping necessary, but you get the hang of it fairly quickly.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Feb 2016 14:26:27 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/02/29/my-git-aliases/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/02/29/my-git-aliases/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 3</title>
        <description>&lt;p&gt;I’ve been neglecting the updates, but here we go! Since the last update, I got
a prototype out, but it was something that wasn’t on my list… I need to
figure out if it counts as one of the 10 or not :-)&lt;/p&gt;

&lt;h1 id=&quot;rust-bisect&quot;&gt;rust-bisect&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect&quot;&gt;rust-bisect&lt;/a&gt; is a little tool to help track down changes in Rust nightlies. It
works a lot like &lt;code&gt;git bisect run&lt;/code&gt;. You give it a command, a nightly build where
it succeeds, and a nightly build where it fails, and it does binary search to
find the first nightly where it fails.&lt;/p&gt;

&lt;h1 id=&quot;cargo-fmt-diff&quot;&gt;cargo fmt-diff&lt;/h1&gt;

&lt;p&gt;I’ve decided to give a name to the project formerly described as ‘rustfmt line
range &amp;amp; diff reading (format a patch)’: &lt;code&gt;cargo fmt-diff&lt;/code&gt;. It’ll be a command
you can run to format the lines you’ve changed. Ideally, you’ll be able to put
it in a VCS commit hook, and never introduce bad formatting. Think of it as a
style-oriented analogue of not rocket science:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;The Not Rocket Science Rule Of Software Engineering:&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;automatically maintain a repository of code that always passes all the tests&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;―&lt;a href=&quot;http://graydon2.dreamwidth.org/1597.html&quot;&gt;Graydon Hoare&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A (very!) rough plan of how I intend to get this done:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;add command line flag that takes a set of line ranges to format (progress:
&lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/issues/844&quot;&gt;rustfmt PR #844, ‘rustfmt: Add an ineffectual –file-lines flag behind a
feature’&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;parse a unified diff to get sets of line ranges to pass to the above flag&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you’re especially interested in this feature, the rustfmt issue to track is
&lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/issues/434&quot;&gt;#434&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;containy-thing-name-tbc&quot;&gt;containy-thing (name TBC)&lt;/h1&gt;

&lt;p&gt;I’m promoting a project I was working on over the holidays onto my list of 10:
containy-thing. It was formerly described as ‘container thing for running
commands in container context without privileges’, and I mentioned it in &lt;a href=&quot;http://kamalmarhubi.com/blog/2016/01/26/eat-your-greens-and-read-your-man-pages/&quot;&gt;Eat
your greens and read your man pages&lt;/a&gt; a month ago. The goal is to
allow running commands in a container environment without root privileges. I
just pushed up &lt;a href=&quot;https://github.com/kamalmarhubi/containy-thing&quot;&gt;a basic repository&lt;/a&gt; for it.&lt;/p&gt;

&lt;h1 id=&quot;rust-and-the-update-framework&quot;&gt;Rust and The Update Framework&lt;/h1&gt;

&lt;p&gt;I’m also promoting a fairly ambitious project onto the list of ten. In the list
of 100, it was cryptically described as ‘tuf + rust + crates’. The goal of this
project is to secure the Rust crate ecosystem using &lt;a href=&quot;http://theupdateframework.com/&quot;&gt;The Update Framework&lt;/a&gt;
(TUF). I’ve been interested in this project since well before I wrote any Rust.
Verifiable provenance of software artifacts is extremely important, and Rust
absolutely should have a good approach to it.&lt;/p&gt;

&lt;p&gt;The Update Framework is a really well-designed and well-thought out approach to
securing software updates and distribution. It’s being implemented for Python,
Docker, and other ecosystems. While I was in New York attending the Recurse
Center, I met up with the researchers behind TUF (&lt;a href=&quot;https://github.com/rust-lang/crates.io/issues/75#issuecomment-179904144&quot;&gt;minutes&lt;/a&gt;) to talk about
implementing it for Rust, but I hadn’t followed up until recently. The issue to
watch for this one is &lt;a href=&quot;https://github.com/rust-lang/crates.io/issues/75&quot;&gt;#75&lt;/a&gt; on the Crates.io repository.&lt;/p&gt;

&lt;p&gt;This project is really exciting, and more than a little bit scary because of
how important it is to get right. But I won’t be working on it alone, so that’s
great! The first steps are to refamiliarize myself with TUF, and then put
together a Rust RFC. The TUF folks have recently had &lt;a href=&quot;https://isis.poly.edu/~jcappos/papers/kuppusamy_nsdi_16.pdf&quot;&gt;a paper
accepted&lt;/a&gt; that describes how they have improved TUF even further,
and I’m starting with reading that.&lt;/p&gt;

&lt;h1 id=&quot;summary-of-the-list-of-ten&quot;&gt;Summary of the list-of-ten:&lt;/h1&gt;

&lt;p&gt;My list of ten now contains four projects:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cargo fmt-diff&lt;/li&gt;
  &lt;li&gt;containy-thing&lt;/li&gt;
  &lt;li&gt;silly memcached or redis-speaking key value store whose nature of silliness
is as yet undisclosed&lt;/li&gt;
  &lt;li&gt;TUF and Crates.io&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 29 Feb 2016 13:17:09 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/02/29/100-10-1-update-3/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/02/29/100-10-1-update-3/</guid>
        
        
      </item>
    
      <item>
        <title>rust-bisect: tracking down the Rust nightly that changed some behavior</title>
        <description>&lt;p&gt;After a bit more tinkering that expected, I’m finally (almost&lt;sup id=&quot;fnref:almost&quot;&gt;&lt;a href=&quot;#fn:almost&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;) releasing my first
Rust crate!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect&quot;&gt;rust-bisect&lt;/a&gt; helps track down when a change—usually a bug!—was
introduced into Rust. Rather than &lt;code&gt;git bisect&lt;/code&gt; directly on the Rust repository,
it uses nightly builds to speed up the process. This is faster in at least a
couple of ways:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;at over 100 pull requests merged per week, there are far more commits
to bisect than there are nightly builds&lt;/li&gt;
  &lt;li&gt;to run an individual test, all rust-bisect needs to do is download the
nightly: no slow Rust build at each step!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This was a really fun project to work on! I made a few changes to related
crates, and even had to solve a stereotypical &lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect/blob/master/src/bisect.rs&quot;&gt;algorithms interview
problem&lt;/a&gt;. And of course, there’s something extremely satisfying about
seeing it bisect and actually find the right nightly…&lt;/p&gt;

&lt;h1 id=&quot;try-it-out&quot;&gt;Try it out!&lt;/h1&gt;

&lt;p&gt;If you want to give it a shot, check out &lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect&quot;&gt;the repository&lt;/a&gt;—especially the
&lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect#example&quot;&gt;example&lt;/a&gt;!  I’d &lt;em&gt;really&lt;/em&gt; love to hear if this is useful to you. And please &lt;a href=&quot;https://github.com/kamalmarhubi/rust-bisect/issues&quot;&gt;open
issues&lt;/a&gt; if you come across any bugs!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:almost&quot;&gt;

      &lt;p&gt;It’s not on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; yet because it’s using some unreleased changes to
&lt;a href=&quot;https://github.com/Diggsey/multirust-rs&quot;&gt;multirust-rs&lt;/a&gt;… &lt;a href=&quot;https://github.com/Diggsey/multirust-rs/issues/54&quot;&gt;soon though&lt;/a&gt;! &lt;a href=&quot;#fnref:almost&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 23 Feb 2016 16:36:47 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/02/23/rust-bisect-tracking-down-the-rust-nightly-that-changed-some-behavior/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/02/23/rust-bisect-tracking-down-the-rust-nightly-that-changed-some-behavior/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 2</title>
        <description>&lt;p&gt;I’m still being slow on picking the 10, but I’ve added a new one to the list. It
now stands at two items!&lt;/p&gt;

&lt;h2 id=&quot;a-very-silly-key-value-store&quot;&gt;A very silly key-value store&lt;/h2&gt;
&lt;p&gt;I’m really excited about the new idea. It’s a very silly key-value store. The
exact nature of the silliness will wait until I’m further along. I’ll make it
speak either the memcached or redis protocol—or both! This makes it fit under
one or both of these items from the &lt;a href=&quot;http://kamalmarhubi.com/blog/2016/01/25/100-10-1/&quot;&gt;original 100&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;memcached speaking thing&lt;/li&gt;
  &lt;li&gt;redis speaking thing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’ll be doing this in Rust—naturally. As a bit of preparation, I’ve already added
&lt;a href=&quot;https://github.com/rust-lang-nursery/libc/pull/170&quot;&gt;&lt;code&gt;sendfile(2)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/rust-lang-nursery/libc/pull/172&quot;&gt;&lt;code&gt;splice(2)&lt;/code&gt;, &lt;code&gt;tee(2)&lt;/code&gt;, and
&lt;code&gt;vmsplice(2)&lt;/code&gt;&lt;/a&gt; to the libc crate, and am working on adding them to
&lt;a href=&quot;https://github.com/carllerche/nix-rust&quot;&gt;nix&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once that’s done, I should be able to start on the silly part! :-)&lt;/p&gt;

&lt;h2 id=&quot;rustfmt-diff-formatting&quot;&gt;rustfmt diff formatting&lt;/h2&gt;
&lt;p&gt;I finally got &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/pull/812&quot;&gt;a pull request&lt;/a&gt; tidying up some config stuff
merged. This was neither my &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/pull/795&quot;&gt;first attempt&lt;/a&gt; nor my &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/pull/801&quot;&gt;second
attempt&lt;/a&gt;, but it got there eventually!&lt;/p&gt;

&lt;p&gt;I’ve exhausted what I’ve decided was some &lt;a href=&quot;http://composition.al/blog/2015/12/29/refactoring-as-a-way-to-understand-code/&quot;&gt;refactoring as a way to understand
code&lt;/a&gt;, but have not made a start on the actual task quite yet. I’m
working on a couple of other Rust developer infrastructure kinds of projects in
the meantime, but should get on with this one. I &lt;em&gt;really&lt;/em&gt; want to be able to
run &lt;code&gt;cargo fmt-diff&lt;/code&gt; or whatever the command ends up being.&lt;/p&gt;

</description>
        <pubDate>Tue, 09 Feb 2016 22:04:15 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/02/09/100-10-1-update-2/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/02/09/100-10-1-update-2/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1 update 1</title>
        <description>&lt;p&gt;I’m going to try and write little updates as I work on &lt;a href=&quot;http://kamalmarhubi.com/blog/2016/01/25/100-10-1/&quot;&gt;100:10:1&lt;/a&gt;.
Here’s the first!&lt;/p&gt;

&lt;h1 id=&quot;picking-1-of-the-10&quot;&gt;Picking 1 of the 10&lt;/h1&gt;

&lt;p&gt;I haven’t made my short list of 10 prototypes quite yet, but I have picked one
of them. Loads of the projects I’m thinking of are in Rust, so I’m preemptively
shaving a yak and working on making the &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt&quot;&gt;rustfmt&lt;/a&gt; formatting tool work
incrementally. This was in the original list of 100 as&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;rustfmt line range &amp;amp; diff reading (format a patch)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Translating from Kamal-scribble-speak: make it so that rustfmt can format only a
specific set of lines. Then on top of that, make it format only the lines that
have changed according to a diff. This way you can always run rustfmt, safe in
the knowledge that it won’t be sticking all kinds of style changes across the
codebase along with your actual changes. It should even be possible to put it in
a pre-commit hook.&lt;/p&gt;

&lt;p&gt;I actually &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/issues/434&quot;&gt;filed an issue&lt;/a&gt; about this back in October, and even started
trying to work on it. It turns out it’s really hard to implement something
non-trivial in a codebase you’re unfamiliar with in a language you don’t know.&lt;/p&gt;

&lt;p&gt;But I’ve been doing some Rust since then, including working on &lt;a href=&quot;https://github.com/rust-lang/rust/pull/31056&quot;&gt;a patch to the
standard library&lt;/a&gt;. I’m way more fluent now, though there are still some
bits of the Rust library and type system I need to absorb further.&lt;/p&gt;

&lt;p&gt;Working myself up to the line ranges change, I’ve put &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/pulls?utf8=%E2%9C%93&amp;amp;q=is%3Apr+author%3Akamalmarhubi+created%3A2016-01-31..2016-02-02&quot;&gt;a bunch of improvements
out&lt;/a&gt;, mostly small. The big one was unifying the config object that
is passed through all parts of the formatting process. This will give me a place
to store the line ranges to be formatted. I’m waiting on &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/pull/801&quot;&gt;the
review&lt;/a&gt; for it:&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;tfw you want someone to review your code from 5 hours ago but they are in new zealand&lt;/p&gt;&amp;mdash; Kamal Marhubi (@kamalmarhubi) &lt;a href=&quot;https://twitter.com/kamalmarhubi/status/694639801765527552&quot;&gt;February 2, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;h1 id=&quot;up-next&quot;&gt;Up next&lt;/h1&gt;

&lt;p&gt;Actually implement the thing! I’ll probably write up some notes as I do this.
I’m pretty glad to have picked this project because it involves getting to know
a bit about how the Rust &lt;abbr title=&quot;abstract syntax tree&quot;&gt;AST&lt;/abbr&gt; is organized.&lt;/p&gt;

&lt;p&gt;rustfmt is an &lt;abbr title=&quot;abstract syntax tree&quot;&gt;AST&lt;/abbr&gt;-based formatter, rather than a token-based one. Instead of
moving bits of text around, it actually parses the entire program, and then
pretty prints it according to style rules. There’s &lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt/blob/master/Design.md&quot;&gt;a brief outline of the
design&lt;/a&gt; that’s pretty good if you want to read about it.&lt;/p&gt;

&lt;p&gt;For my change, the line ranges need to be translated to a set of &lt;abbr title=&quot;abstract syntax tree&quot;&gt;AST&lt;/abbr&gt; nodes, and
then selectively formatted. There will be some niggles around sets of lines that
straddle node boundaries which I’ll have to think about. And maybe even draw
some ‘pictures’!&lt;/p&gt;

</description>
        <pubDate>Tue, 02 Feb 2016 22:46:25 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/02/02/100-10-1-update-1/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/02/02/100-10-1-update-1/</guid>
        
        
      </item>
    
      <item>
        <title>Eat your greens and read your man pages</title>
        <description>&lt;p&gt;I’ve been working on a little tool to let unprivileged users run commands in
the context of a container image’s filesystem on Linux.  I’m really bad at
names, so let’s call it &lt;code&gt;containy-thing&lt;/code&gt;. That also evokes about the right
level of completeness: it’s quite far from done.&lt;/p&gt;

&lt;p&gt;Anyway, this is a little field report from working on it. Its moral is: read
your man pages.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;containy-thing&lt;/code&gt; uses a few Linux tricks to do its job, the main ones being
&lt;a href=&quot;http://man7.org/linux/man-pages/man7/user_namespaces.7.html&quot;&gt;user&lt;/a&gt; and mount &lt;a href=&quot;http://man7.org/linux/man-pages/man7/namespaces.7.html&quot;&gt;namespaces&lt;/a&gt;. It takes a directory to use as the
container root filesystem, and a command to run, and runs the command. If
you’ve used docker,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ containy-thing /path/to/rootfs /bin/ls -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would be similar to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run my-image /bin/ls -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note the &lt;code&gt;$&lt;/code&gt; vs &lt;code&gt;#&lt;/code&gt; prompts! The main point of this project is that you can
run it as an unprivileged user; docker needs superuser privileges.)&lt;/p&gt;

&lt;p&gt;I was trying to test it out and had an extracted root filesystem for an
Ubuntu-derived image. I attempted to run &lt;code&gt;/bin/ls -l&lt;/code&gt;, but it kept failing.
Investigating a bit, I found that the &lt;code&gt;execve(2)&lt;/code&gt; system call to start
&lt;code&gt;/bin/ls&lt;/code&gt; was failing with &lt;code&gt;EACCES&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;read-your-man-pages&quot;&gt;read your man pages&lt;/h1&gt;

&lt;p&gt;I’ve done bits and pieces of systems programming, and the man pages are pretty
great most of the time. The man page for &lt;a href=&quot;http://man7.org/linux/man-pages/man2/execve.2.html#ERRORS&quot;&gt;&lt;code&gt;execve(2)&lt;/code&gt;&lt;/a&gt; definitely falls
under ‘most of the time’, and is pretty exhaustive. It lists the circumstances
that could result in &lt;code&gt;EACCES&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       EACCES Search permission is denied on a component of the path prefix of
              filename or the name of a script interpreter.  (See also
              path_resolution(7).)

       EACCES The file or a script interpreter is not a regular file.

       EACCES Execute permission is denied for the file or a script or ELF
              interpreter.

       EACCES The filesystem is mounted noexec.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I went through these one by one:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;checked that all path components (namely, &lt;code&gt;/bin&lt;/code&gt;) had the search permission
(&lt;code&gt;a+x&lt;/code&gt;) set (&lt;code&gt;/bin/ls&lt;/code&gt; is not a script, and so there was no script
interpreter to check)&lt;/li&gt;
  &lt;li&gt;checked that &lt;code&gt;/bin/ls&lt;/code&gt; was there, and was a file&lt;/li&gt;
  &lt;li&gt;checked that &lt;code&gt;/bin/ls&lt;/code&gt;/ had the execute permission (&lt;code&gt;a+x&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;double checked the mount to be sure it wasn’t &lt;code&gt;noexec&lt;/code&gt;, which disallows
execution of all files on the filesystem&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nothing came up. I did this a bunch of times, and still nothing came up.&lt;/p&gt;

&lt;h1 id=&quot;no-really-read-your-man-pages&quot;&gt;no really, read your man pages&lt;/h1&gt;

&lt;p&gt;Eventually, I finally realized what the problem was. The third reason for
&lt;code&gt;EACCES&lt;/code&gt; was&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       EACCES Execute permission is denied for the file or a script or ELF
              interpreter.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but I was reading&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       EACCES Execute permission is denied for the file or a script       
              interpreter.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I didn’t even stop to think that something could be wrong with the ELF
interpreter. I only even vaguely understand what an ELF interpreter does! But
after wasting probably a day and a bit trying to figure this out, I finally
took a look. The interpreter for x86-64 programs on Linux is at
&lt;code&gt;/lib64/ld-linux-x86-64.so.2&lt;/code&gt;, at least on Debian and Ubuntu…. and its
permissions were wrong.&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Jan 2016 10:19:54 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/01/26/eat-your-greens-and-read-your-man-pages/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/01/26/eat-your-greens-and-read-your-man-pages/</guid>
        
        
      </item>
    
      <item>
        <title>100:10:1</title>
        <description>&lt;p&gt;Last week I decided to join &lt;a href=&quot;https://writing.natwelch.com/&quot;&gt;Nat&lt;/a&gt; and &lt;a href=&quot;http://redlua.com/&quot;&gt;Steve&lt;/a&gt; and make an attempt at the
100:10:1 project idea generation / implementation idea &lt;a href=&quot;https://nickbentleygames.wordpress.com/2014/05/12/the-100-10-1-method-for-game-design/&quot;&gt;Nick
Bentley&lt;/a&gt; wrote about in the context of game design, and
&lt;a href=&quot;http://blog.fogus.me/2015/11/04/the-100101-method-my-approach-to-open-source/&quot;&gt;fogus adapted to open source projects&lt;/a&gt;. It’s a three step process:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;come up with 100 project ideas&lt;/li&gt;
  &lt;li&gt;build MVPs for 10 of them&lt;/li&gt;
  &lt;li&gt;develop 1 of them into a complete thing&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I’m playing catch up with Nat and Steve, who both have their 100 and 10 already
picked out! But I’ve got my 100 ideas together now, which are listed at the end
of this post without any organization.&lt;/p&gt;

&lt;p&gt;Some takeaways from doing this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I’m &lt;em&gt;really&lt;/em&gt; interested in lower level / infrastructure / systems stuff at
the moment&lt;/li&gt;
  &lt;li&gt;I really like Rust&lt;/li&gt;
  &lt;li&gt;I really like Kubernetes&lt;/li&gt;
  &lt;li&gt;and some other things&lt;/li&gt;
  &lt;li&gt;not much in the way of producty or goofy ideas as compared to the other two, but there you go!&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;100&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;heroku clone on kubernetes&lt;/li&gt;
  &lt;li&gt;container thing for running commands in container context without privileges&lt;/li&gt;
  &lt;li&gt;rust high perf networking http server (techempower benchmarks, haywire)&lt;/li&gt;
  &lt;li&gt;rust async library experiments: curio, asyncio, folly, util::Task&lt;/li&gt;
  &lt;li&gt;rust ideas around cancellation for async: util::Task, golang.org/x/net/context, C# CancellationToken&lt;/li&gt;
  &lt;li&gt;rust lib to restart without dropping connections&lt;/li&gt;
  &lt;li&gt;tuf + rust + crates&lt;/li&gt;
  &lt;li&gt;kythe extractor / indexer for rust&lt;/li&gt;
  &lt;li&gt;kythe (?) based github search that doesn’t suck&lt;/li&gt;
  &lt;li&gt;kythe browser that works nice&lt;/li&gt;
  &lt;li&gt;package pageshot for sandstorm&lt;/li&gt;
  &lt;li&gt;static site generator using service worker / amp / … ?&lt;/li&gt;
  &lt;li&gt;graphiql / graphql for jsonapi&lt;/li&gt;
  &lt;li&gt;“cloud” load balancer for kubernetes&lt;/li&gt;
  &lt;li&gt;criu + cap’n proto (?) for magic on-demand lb&lt;/li&gt;
  &lt;li&gt;implement tcp/ip (in rust?)&lt;/li&gt;
  &lt;li&gt;build reliable communication on top of udp&lt;/li&gt;
  &lt;li&gt;cap’n proto shared memory transport&lt;/li&gt;
  &lt;li&gt;cap’n proto mmap message builder&lt;/li&gt;
  &lt;li&gt;figure out userfaultfd for the above&lt;/li&gt;
  &lt;li&gt;ebpf based strace&lt;/li&gt;
  &lt;li&gt;seccomp (bpf) for rust&lt;/li&gt;
  &lt;li&gt;multiprocess lib for rust&lt;/li&gt;
  &lt;li&gt;pledge clone for linux using seccomp-bpf + namespaces&lt;/li&gt;
  &lt;li&gt;extend roaring bitmap rust to handle runs&lt;/li&gt;
  &lt;li&gt;rust clap bash completions&lt;/li&gt;
  &lt;li&gt;x_things twitter bot generator – creates bot, heroku app, sends credentials&lt;/li&gt;
  &lt;li&gt;window tiny lfu (w-tinylfu) cache gh/ben-manes/caffeine/wiki/efficiency&lt;/li&gt;
  &lt;li&gt;cap’n proto compiler bootstrapping with json&lt;/li&gt;
  &lt;li&gt;debugger (500 lines)&lt;/li&gt;
  &lt;li&gt;test tool at syscall interface (ptrace / seccomp bpf?)&lt;/li&gt;
  &lt;li&gt;explore allowing overlayfs with namespace owned mounts&lt;/li&gt;
  &lt;li&gt;kubernetes + timely dataflow&lt;/li&gt;
  &lt;li&gt;rustfmt line range &amp;amp; diff reading (format a patch)&lt;/li&gt;
  &lt;li&gt;rustdoc improvements: stable since, target differences&lt;/li&gt;
  &lt;li&gt;package firefox sync for sandstorm&lt;/li&gt;
  &lt;li&gt;fuzz cap’n proto rust&lt;/li&gt;
  &lt;li&gt;AFL + quickcheck: coverage directed fuzzing for rust / testing&lt;/li&gt;
  &lt;li&gt;markdown editor with gdoc like commenting and suggesting&lt;/li&gt;
  &lt;li&gt;port rustc build to bazel&lt;/li&gt;
  &lt;li&gt;port cap’n proto build to bazel&lt;/li&gt;
  &lt;li&gt;port sandstorm build to bazel&lt;/li&gt;
  &lt;li&gt;web-based handbell ringing app&lt;/li&gt;
  &lt;li&gt;bazel docker improvements&lt;/li&gt;
  &lt;li&gt;bazel appc rules&lt;/li&gt;
  &lt;li&gt;kubernetes appc support&lt;/li&gt;
  &lt;li&gt;bazel rust rules support cross compilation&lt;/li&gt;
  &lt;li&gt;csmith for rust (generate random programs)&lt;/li&gt;
  &lt;li&gt;blue line cenerator / viewer for web&lt;/li&gt;
  &lt;li&gt;composition checker&lt;/li&gt;
  &lt;li&gt;ringing social app (a la ravelry?) with peal &amp;amp; qp reports&lt;/li&gt;
  &lt;li&gt;octopus holdings zulip bot&lt;/li&gt;
  &lt;li&gt;two corpus twitter bot generator (a la erowidrecruiter)&lt;/li&gt;
  &lt;li&gt;rust crate version vs rust language version&lt;/li&gt;
  &lt;li&gt;hybrid logical clock implementation (rust?)&lt;/li&gt;
  &lt;li&gt;impelemnt a crdt&lt;/li&gt;
  &lt;li&gt;implement a consensus protocol&lt;/li&gt;
  &lt;li&gt;create an official backport for debian – nodejs?&lt;/li&gt;
  &lt;li&gt;create an official package for debian – watchman?&lt;/li&gt;
  &lt;li&gt;egit shallow clone OR allow shallow clone via git for bazel&lt;/li&gt;
  &lt;li&gt;swagger client generator for rust&lt;/li&gt;
  &lt;li&gt;implement perfect consistent hashing arXiv:1503:04988&lt;/li&gt;
  &lt;li&gt;elevator algorithm competition site&lt;/li&gt;
  &lt;li&gt;port google research benchmark thing to rust (r/rust/comments/42fnw7)&lt;/li&gt;
  &lt;li&gt;clocks traits for rust&lt;/li&gt;
  &lt;li&gt;rust bridge project investigation – os?&lt;/li&gt;
  &lt;li&gt;rust cstring ergonomics improvements&lt;/li&gt;
  &lt;li&gt;pure rust ssh2 implementation&lt;/li&gt;
  &lt;li&gt;server side bindings for libssh2 rust&lt;/li&gt;
  &lt;li&gt;rust ci iuld for windows on appveyor&lt;/li&gt;
  &lt;li&gt;lmax disruptor implementation&lt;/li&gt;
  &lt;li&gt;implement some lock free data structures&lt;/li&gt;
  &lt;li&gt;cache friendly data structures for rust&lt;/li&gt;
  &lt;li&gt;figure out swagger &amp;amp; json api&lt;/li&gt;
  &lt;li&gt;something like scapy for network playing around but in rust&lt;/li&gt;
  &lt;li&gt;rust take on jgc’s little parallel do stuff library&lt;/li&gt;
  &lt;li&gt;memcached speaking thing&lt;/li&gt;
  &lt;li&gt;redis speaking thing&lt;/li&gt;
  &lt;li&gt;spliterator for rust (if it makes sense)&lt;/li&gt;
  &lt;li&gt;gitsync w/ray&lt;/li&gt;
  &lt;li&gt;ssh multiplexer / proxy thing (?)&lt;/li&gt;
  &lt;li&gt;custom replacement of the screen-on app thing on android with timeouts built in&lt;/li&gt;
  &lt;li&gt;hyper log log on timely dataflow&lt;/li&gt;
  &lt;li&gt;command line client for banq&lt;/li&gt;
  &lt;li&gt;command line client for tangerine&lt;/li&gt;
  &lt;li&gt;token bucket in rust&lt;/li&gt;
  &lt;li&gt;rethinkdb client in rust&lt;/li&gt;
  &lt;li&gt;rust config library using command line flags, env vars, config files (w/overriding)&lt;/li&gt;
  &lt;li&gt;SHIM tracing framework… high frequency sampling profiler&lt;/li&gt;
  &lt;li&gt;prometheus client for rust&lt;/li&gt;
  &lt;li&gt;hdr histograms for prometheus&lt;/li&gt;
  &lt;li&gt;stats / metrics for rust (gh/rust-lang/rfcs/issue/843)&lt;/li&gt;
  &lt;li&gt;fd transfer for cap’n proto&lt;/li&gt;
  &lt;li&gt;trusted build service (toto)&lt;/li&gt;
  &lt;li&gt;rust libc generator or test constants (&amp;amp; signatures?)&lt;/li&gt;
  &lt;li&gt;sites &amp;amp; mobile app that lets my family track our locations&lt;/li&gt;
  &lt;li&gt;something like the original hangouts – say you’re vailable to hangout (again, family)&lt;/li&gt;
  &lt;li&gt;tool to blas through images and highlight some picks as video&lt;/li&gt;
  &lt;li&gt;god bold rustc asm output thing (historical)&lt;/li&gt;
  &lt;li&gt;grpc for rust&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Jan 2016 17:03:49 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2016/01/25/100-10-1/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2016/01/25/100-10-1/</guid>
        
        
      </item>
    
      <item>
        <title>Squashing Docker images with Btrfs</title>
        <description>&lt;p&gt;Here’s a small hack for squashing a Docker image to a single layer if you
happen to run with &lt;code&gt;/var/lib&lt;/code&gt; on a Btrfs filesystem. The output will be a tar
file you can use with &lt;a href=&quot;http://docs.docker.com/engine/reference/builder/#add&quot;&gt;&lt;code&gt;ADD&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;Dockerfile&lt;/code&gt; to create a flat
base image.&lt;/p&gt;

&lt;p&gt;This is an alternative to &lt;a href=&quot;http://docs.docker.com/engine/reference/commandline/create/&quot;&gt;&lt;code&gt;docker create&lt;/code&gt;&lt;/a&gt;-ing a container and
running &lt;a href=&quot;http://docs.docker.com/engine/reference/commandline/export/&quot;&gt;&lt;code&gt;docker export&lt;/code&gt;&lt;/a&gt; on it to get the filesystem contents.
It saves you having to &lt;a href=&quot;http://docs.docker.com/engine/reference/commandline/rm/&quot;&gt;&lt;code&gt;docker rm&lt;/code&gt;&lt;/a&gt; the container afterwards.&lt;/p&gt;

&lt;p&gt;First, get the ID of the image you want to squash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker images rethink
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
rethinkdb           latest              ffb24b60063b        6 days ago          181.8 MB
rethinkdb           2.0.4               83d2da4505dc        2 weeks ago         195.8 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I’ll go with the latest version, &lt;code&gt;ffb24b60063b&lt;/code&gt;. This is a prefix of the full
image ID. The image will be a Btrfs snapshot in
&lt;code&gt;/var/lib/docker/Btrfs/subvolumes&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo -i
# cd /var/lib/docker/btrfs/subvolumes
# ls -d ffb24b60063b*
ffb24b60063ba7e26ebf2f888deb5af0c8966dcbb612353fcd0c5d52a0a1d234
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&quot;http://docs.docker.com/engine/userguide/storagedriver/btrfs-driver/&quot;&gt;Btrfs storage driver’s documentation&lt;/a&gt; goes into a
fair bit of detail on how the driver uses Btrfs subvolumes and snapshots for
images and containers.&lt;/p&gt;

&lt;p&gt;Here’s an exerpt from &lt;a href=&quot;https://github.com/justone/dockviz&quot;&gt;&lt;code&gt;dockviz&lt;/code&gt;&lt;/a&gt; output for that image that shows the
various layers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├─1565e86129b8 Virtual Size: 125.1 MB
│ └─a604b236bcde Virtual Size: 125.1 MB Tags: debian:latest
│   └─3012d15ee771 Virtual Size: 125.1 MB
│     └─67ab878cc688 Virtual Size: 125.1 MB
│       └─d4d9554f3430 Virtual Size: 125.1 MB
│         └─d4bdd500e4ec Virtual Size: 125.1 MB
│           └─9c56aa19b706 Virtual Size: 181.8 MB
│             └─9102e5038f43 Virtual Size: 181.8 MB
│               └─c5dff5ddf6a8 Virtual Size: 181.8 MB
│                 └─769806cae856 Virtual Size: 181.8 MB
│                   └─ffb24b60063b Virtual Size: 181.8 MB Tags: rethinkdb:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it’s just a matter of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo -i
# cd /var/lib/docker/btrfs/subvolumes/ffb24b60063ba7e26ebf2f888deb5af0c8966dcbb612353fcd0c5d52a0a1d234
# tar c . &amp;gt; /tmp/rethink-squashed.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tab completion should pick up the full directory name from the short image ID,
so you don’t have to copy the complete ID.&lt;/p&gt;

&lt;p&gt;That’s pretty much it. You can get a flat base image with a &lt;code&gt;Dockerfile&lt;/code&gt;
with these contents:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM sratch
ADD rethink-squashed.tar /
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 27 Nov 2015 14:44:03 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/11/27/squashing-docker-images-with-btrfs/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/11/27/squashing-docker-images-with-btrfs/</guid>
        
        
      </item>
    
      <item>
        <title>Using strace to figure out how git push over SSH works</title>
        <description>&lt;p&gt;Yesterday I was curious about how &lt;code&gt;git push&lt;/code&gt; works over SSH. I’m getting more
used to using &lt;code&gt;strace&lt;/code&gt; to figure this kind of thing out, so I gave it a shot.
If I &lt;code&gt;strace&lt;/code&gt; pushing to this site’s repository, this shows up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[pid 15943] execve(&quot;/usr/bin/ssh&quot;, [&quot;ssh&quot;, &quot;git@github.com&quot;, &quot;git-receive-pack &#39;kamalmarhubi/w&quot;...], [/* 51 vars */]) = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;code&gt;git push&lt;/code&gt; eventually calls &lt;code&gt;ssh git@github.com git-receive-pack &amp;lt;repo-path&amp;gt;&lt;/code&gt;.
Trying this out at my terminal gives me this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh git@github.com git-receive-pack kamalmarhubi/website
00bb29793c39c8e4bfec627d60938c4ed2086cc60bb1 refs/heads/gh-pagesreport-status delete-refs side-band-64k quiet atomic ofs-delta agent=git/2:2.4.8~upload-pack-wrapper-script-1211-gc27b061
003f04bfcb3e238e5660ae9e71a6ce99f472211fe85f refs/heads/master
0000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with the terminal waiting for my input. SSH is used to handle authentication
and remote connection, and then it runs a command at the other end to handle
the data exchange. These lines are the start of that exchange.&lt;/p&gt;

&lt;p&gt;A tiny bit of looking around the internet told me that the protocol is made up
of lines prefixed by their length as 4 hex digits. Then it looks like a commit
SHA-1 and a ref. The sender terminates with &lt;code&gt;0000&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There are a couple of lines here, one for each branch in the repository. The
first line additionally has a bunch of stuff at the end that looks like a
description of what the sending program is and some features it supports.&lt;/p&gt;

&lt;p&gt;While I was looking into this, I used &lt;code&gt;xsel&lt;/code&gt; to copy the output to paste into
an editor. This was really confusing, because all that got pasted was the first
line without all the metadata!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;00bb29793c39c8e4bfec627d60938c4ed2086cc60bb1 refs/heads/gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at the entire output through &lt;code&gt;hexdump -C&lt;/code&gt;, it turns out that there’s a
null byte after &lt;code&gt;refs/heads/gh-pages&lt;/code&gt;, and then a newline at the end (marked with &lt;code&gt;*&lt;/code&gt; below):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;00000000  30 30 62 62 32 39 37 39  33 63 33 39 63 38 65 34  |00bb29793c39c8e4|
00000010  62 66 65 63 36 32 37 64  36 30 39 33 38 63 34 65  |bfec627d60938c4e|
00000020  64 32 30 38 36 63 63 36  30 62 62 31 20 72 65 66  |d2086cc60bb1 ref|
00000030  73 2f 68 65 61 64 73 2f  67 68 2d 70 61 67 65 73  |s/heads/gh-pages|
00000040 *00*72 65 70 6f 72 74 2d  73 74 61 74 75 73 20 64  |.report-status d|
00000050  65 6c 65 74 65 2d 72 65  66 73 20 73 69 64 65 2d  |elete-refs side-|
00000060  62 61 6e 64 2d 36 34 6b  20 71 75 69 65 74 20 61  |band-64k quiet a|
00000070  74 6f 6d 69 63 20 6f 66  73 2d 64 65 6c 74 61 20  |tomic ofs-delta |
00000080  61 67 65 6e 74 3d 67 69  74 2f 32 3a 32 2e 34 2e  |agent=git/2:2.4.|
00000090  38 7e 75 70 6c 6f 61 64  2d 70 61 63 6b 2d 77 72  |8~upload-pack-wr|
000000a0  61 70 70 65 72 2d 73 63  72 69 70 74 2d 31 32 31  |apper-script-121|
000000b0  31 2d 67 63 32 37 62 30  36 31*0a*30 30 33 66 37  |1-gc27b061.003f7|
000000c0  39 32 66 34 39 36 65 37  35 33 64 62 39 33 33 30  |92f496e753db9330|
000000d0  66 30 61 34 65 38 32 39  30 62 38 61 36 63 62 61  |f0a4e8290b8a6cba|
000000e0  38 61 62 36 64 61 62 20  72 65 66 73 2f 68 65 61  |8ab6dab refs/hea|
000000f0  64 73 2f 6d 61 73 74 65  72 0a 30 30 30 30        |ds/master.0000|
000000fe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without doing any research, here’s what I think happened. The git folks defined
the fairly simple length-prefixed, newline-separated protocol. Then at some
point they wanted to add some metadata to the protocol without breaking
compatibility with older versions of git. They came up with a nifty hack that
exploits C’s null-terminated strings: add the metadata after a null byte but
before the newline. This way, reading up to a newline will get all the
metadata. The metadata-processing code knows to look past the null byte, but
the existing protocol code would see only the part up before it, presumably
letting it worked unchanged!&lt;/p&gt;

&lt;p&gt;And when I copied it using &lt;code&gt;xsel&lt;/code&gt;, the stuff past the null byte got skipped.&lt;/p&gt;

&lt;p&gt;Cute hack, and mystery solved!&lt;/p&gt;
</description>
        <pubDate>Sat, 21 Nov 2015 23:48:22 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/11/21/using-strace-to-figure-out-how-git-push-over-ssh-works/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/11/21/using-strace-to-figure-out-how-git-push-over-ssh-works/</guid>
        
        
      </item>
    
      <item>
        <title>Kubernetes from the ground up: the scheduler</title>
        <description>&lt;p&gt;&lt;em&gt;This is the third post in a series on &lt;a href=&quot;https://kubernetes.io/&quot;&gt;Kubernetes&lt;/a&gt;, the open source cluster
manager. The earlier posts were about &lt;a href=&quot;http://kamalmarhubi.com/blog/2015/08/27/what-even-is-a-kubelet/&quot;&gt;the kubelet&lt;/a&gt;, and &lt;a href=&quot;http://kamalmarhubi.com/blog/2015/09/06/kubernetes-from-the-ground-up-the-api-server/&quot;&gt;the API
server&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It’s been a while since the last post, but I’m excited to finally finish this
one off. This is about the scheduler, which is the first part of what makes
Kubernetes Kubernetes. The scheduler’s job is to decide where in the cluster to
run our workloads. This lets us stop thinking about which host should run what,
and just declaratively say ‘I want this to be running’.&lt;/p&gt;

&lt;p&gt;When we left off last time, we were able to run a collection of containers on a
specific Kubernetes node by posting a JSON manifest to the API server. We also
got a look at the &lt;code&gt;kubectl&lt;/code&gt;, the command line client for Kubernetes, which
makes it much easier to interact with the cluster.&lt;/p&gt;

&lt;p&gt;Oh, except that until now we haven’t had a cluster, at least not in the sense
of multiple machines. In this post we’re going to change that. To follow along,
you’ll need a few machines—virtual, real, cloud, it doesn’t matter.
What does matter is&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;they are all on the same network&lt;/li&gt;
  &lt;li&gt;they all have Docker installed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’ve got a few machines in the examples below: the master is &lt;code&gt;master&lt;/code&gt;, while
the nodes are &lt;code&gt;node1&lt;/code&gt;, &lt;code&gt;node2&lt;/code&gt;. I’m assuming they can all be reached
via their hostnames; feel free to substitute in their IPs instead!&lt;/p&gt;

&lt;h1 id=&quot;starting-the-api-server&quot;&gt;Starting the API server&lt;/h1&gt;

&lt;p&gt;We’re going to breeze through starting the API server, since it’s
all &lt;a href=&quot;http://kamalmarhubi.com/blog/2015/09/06/kubernetes-from-the-ground-up-the-api-server/#starting-the-api-server&quot;&gt;straight out of the last post&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ mkdir etcd-data
master$ docker run --volume=$PWD/etcd-data:/default.etcd \
--detach --net=host quay.io/coreos/etcd &amp;gt; etcd-container-id
master$ wget https://storage.googleapis.com/kubernetes-release/release/v1.1.1/bin/linux/amd64/kube-apiserver
master$ chmod +x kube-apiserver
master$ ./kube-apiserver \
--etcd-servers=http://127.0.0.1:2379 \
--service-cluster-ip-range=10.0.0.0/16 \
--insecure-bind-address=0.0.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only difference is we’ve added &lt;code&gt;--insecure-bind-address=0.0.0.0&lt;/code&gt;. This
allows the kubelets running on the nodes to connect to the API server remotely
without any authentication. Ordinarily, unauthenticated connections are only
allowed from localhost.&lt;/p&gt;

&lt;p&gt;Just to be clear, you &lt;em&gt;really&lt;/em&gt; don’t want to do this in production!&lt;/p&gt;

&lt;p&gt;While we’re here, let’s also get &lt;code&gt;kubectl&lt;/code&gt;, the command line client &lt;a href=&quot;http://kamalmarhubi.com/blog/2015/09/06/kubernetes-from-the-ground-up-the-api-server/#the-kubernetes-command-line-client-kubectl&quot;&gt;we looked
at in the last post&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ wget https://storage.googleapis.com/kubernetes-release/release/v1.1.1/bin/linux/amd64/kubectl
master$ chmod +x kubectl
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;launching-some-nodes&quot;&gt;Launching some nodes&lt;/h1&gt;

&lt;p&gt;This will be quick too, as we’ve done this a couple of times before. The only
difference here is that the API server isn’t running on localhost, so we need
to include its address. I’ve got two nodes, but I’ll just show this once below.
If you’re following along, do this on as many nodes as you want!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node1$ ./kubelet --api-servers=http://master:8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now back on &lt;code&gt;master&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ ./kubectl get nodes
NAME      LABELS                         STATUS    AGE
node1     kubernetes.io/hostname=node1   Ready     2m
node2     kubernetes.io/hostname=node2   Ready     4s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Excellent.&lt;/p&gt;

&lt;h1 id=&quot;running-something-on-the-cluster&quot;&gt;Running something on the cluster&lt;/h1&gt;

&lt;p&gt;Kubernetes runs &lt;em&gt;pods&lt;/em&gt;, which are collections of containers that execute
together.  To start, we’ll create a pod and specify which node it should run
on.&lt;/p&gt;

&lt;p&gt;We’ll continue running our nginx example pod from the earlier posts. Get &lt;a href=&quot;https://raw.githubusercontent.com/kamalmarhubi/kubernetes-from-the-ground-up/master/03-the-scheduler/nginx-with-nodename.yaml&quot;&gt;the
pod manifest&lt;/a&gt;, which specifies which containers to run. We
specify the node to run on by setting the &lt;code&gt;nodeName&lt;/code&gt; field. Edit the file and
set it to run on one of your nodes.  I picked &lt;code&gt;node2&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ wget https://raw.githubusercontent.com/kamalmarhubi/kubernetes-from-the-ground-up/master/03-the-scheduler/nginx-with-nodename.yaml
master$ $EDITOR nginx-with-nodename.yaml  # edit the nodeName field to match a node
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now create the pod:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ ./kubectl create --filename nginx-with-nodename.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can check with &lt;code&gt;kubectl get pods&lt;/code&gt; we see that it got picked up. If you’re
quicker than me, you might catch it in the &lt;code&gt;Pending&lt;/code&gt; state, before the kubelet
starts it, but it should end up &lt;code&gt;Running&lt;/code&gt; fairly quickly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ ./kubectl get pods
NAME                  READY     STATUS    RESTARTS   AGE
nginx-with-nodename   2/2       Running   0          7s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just to be sure it’s actually on &lt;code&gt;node2&lt;/code&gt; as we said, we can &lt;code&gt;kubectl describe&lt;/code&gt;
the pod:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ ./kubectl describe pods/nginx-with-nodename | grep ^Node
Node:                           node2/10.240.0.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can break down what happened here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;initially, the kubelets on each node are watching the API server for pods
they are meant to be running&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;kubectl&lt;/code&gt; created a pod on the API server that’s meant to run on &lt;code&gt;node2&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;the kubelet on &lt;code&gt;node2&lt;/code&gt; noticed the new pod, and so started running it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can also try &lt;a href=&quot;https://raw.githubusercontent.com/kamalmarhubi/kubernetes-from-the-ground-up/master/03-the-scheduler/nginx-without-nodename.yaml&quot;&gt;a pod manifest&lt;/a&gt; that doesn’t specify a
node to run on. In our current setup, this pod will forever sit in the
&lt;code&gt;Pending&lt;/code&gt; state. Let’s try anyway:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ wget https://raw.githubusercontent.com/kamalmarhubi/kubernetes-from-the-ground-up/master/03-the-scheduler/nginx-without-nodename.yaml
master$ ./kubectl create --filename nginx-without-nodename.yaml
master$ ./kubectl get pods
NAME                     READY     STATUS    RESTARTS   AGE
nginx-with-nodename      2/2       Running   0          3m
nginx-without-nodename   0/2       Pending   0          20s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even if you take a break and read the internet for 15 minutes, it’ll still be
there, &lt;code&gt;Pending&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ ./kubectl get pods
NAME                     READY     STATUS    RESTARTS   AGE
nginx-with-nodename      2/2       Running   0          18m
nginx-without-nodename   0/2       Pending   0          15m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Breaking it down in the same way:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;initially, the kubelets on each node are watching the API server for pods
they are meant to be running&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;kubectl&lt;/code&gt; created a pod on the API server without specifying which node to
run on&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;… yeah, nothing’s going to happen.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;the-scheduler&quot;&gt;The scheduler&lt;/h1&gt;

&lt;p&gt;This is where the sheduler comes in: its job is to take pods that aren’t bound
to a node, and assign them one. Once the pod has a node assigned, the normal
behavior of the kubelet kicks in, and the pod gets started.&lt;/p&gt;

&lt;p&gt;Let’s get the scheduler binary and start it running on &lt;code&gt;master&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ wget https://storage.googleapis.com/kubernetes-release/release/v1.1.1/bin/linux/amd64/kube-scheduler
master$ chmod +x kubectl
master$ ./kube-scheduler --master=http://localhost:8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not long after starting the scheduler, the &lt;code&gt;nginx-without-nodename&lt;/code&gt; pod should
get assigned a node and start running.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ ./kubectl get pods
NAME                     READY     STATUS    RESTARTS   AGE
nginx-with-nodename      2/2       Running   0          1h
nginx-without-nodename   2/2       Running   0          1h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we &lt;code&gt;describe&lt;/code&gt; it, we can see which node it got scheduled on:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ ./kubectl describe pods/nginx-without-nodename | grep ^Node
Node:                           node1/10.240.0.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It ended up on &lt;code&gt;node1&lt;/code&gt;! The scheduler tries to spread out pods evenly across
the nodes we have available, so that makes sense. If you’re interested in more
about how the scheduler places pods, there’s a really good &lt;a href=&quot;http://stackoverflow.com/a/28874577&quot;&gt;Stack
Overflow&lt;/a&gt; answer with some details.&lt;/p&gt;

&lt;p&gt;We can also get a list of ‘events’ related to the pod. These are state changes
through the pods lifetime:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ ./kubectl describe pods/nginx-without-nodename | grep -A5 ^Events
Events:
  FirstSeen     LastSeen        Count   From            SubobjectPath                           Reason                  Message
  ─────────     ────────        ─────   ────            ─────────────                           ──────                  ───────
  25m           25m             1       {scheduler }                                            Scheduled               Successfully assigned nginx-without-nodename to node1
  23m           23m             1       {kubelet node1} implicitly required container POD       Pulling                 Pulling image &quot;gcr.io/google_containers/pause:0.8.0&quot;
  23m           23m             1       {kubelet node1} implicitly required container POD       Pulled                  Successfully pulled image &quot;gcr.io/google_containers/pause:0.8.0&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first one shows it getting scheduled, then others are related to the pod
starting up on the node.&lt;/p&gt;

&lt;p&gt;At this point, if you create another pod without specifying a node for it to
run on, the scheduler will place it right away. Try it out!&lt;/p&gt;

&lt;h1 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;/h1&gt;

&lt;p&gt;So now we are able to declaratively specify workloads, and get them scheduled
across our cluster, which is great! But if we actually try connecting to the
nginx servers we have running, we’ll see we have a little problem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master$ ./kubectl describe pods/nginx-with-nodename | grep ^IP
IP:                             172.17.0.2
master$ curl http://172.17.0.2
curl: (7) Failed to connect to 172.17.0.2 port 80: No route to host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This pod is running on &lt;code&gt;node2&lt;/code&gt;. If we go over to that machine,
we get through:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node2$ curl --stderr /dev/null http://172.17.0.2 | head -4
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But our other node can’t reach it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node1$ curl http://172.17.0.2
curl: (7) Failed to connect to 172.17.0.2 port 80: No route to host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the next post, we’ll take a little detour into Kubernetes networking, and
make it possible for containers to talk to each other over the network.&lt;/p&gt;
</description>
        <pubDate>Tue, 17 Nov 2015 17:41:57 -0500</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/11/17/kubernetes-from-the-ground-up-the-scheduler/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/11/17/kubernetes-from-the-ground-up-the-scheduler/</guid>
        
        
      </item>
    
  </channel>
</rss>
