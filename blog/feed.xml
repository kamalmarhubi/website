<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kamal Marhubi</title>
    <description></description>
    <link>http://kamalmarhubi.com/</link>
    <atom:link href="http://kamalmarhubi.com/blog/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 24 Jun 2015 00:01:43 -0400</pubDate>
    <lastBuildDate>Wed, 24 Jun 2015 00:01:43 -0400</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Recurse Center lab notes 2015-06-23</title>
        <description>&lt;p&gt;My output today was to write [an email][email]. I did a whole bunch of reading
up on memory mapped files and handling page faults to get to that point, so I
wasn‚Äôt exactly idle‚Äîjust outputless. I need to remember that it still counts
and being productive, and making good use of time!&lt;/p&gt;
</description>
        <pubDate>Tue, 23 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/23/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/23/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes 2015-06-22</title>
        <description>&lt;p&gt;Today was slightly slow. I re-remembered why it‚Äôs a good idea to leave
things incomplete at the end of the day or week: it gives you somewhere
to start. I consider &lt;a href=&quot;https://github.com/kamalmarhubi/lsaddr&quot;&gt;&lt;code&gt;lsaddr&lt;/code&gt;&lt;/a&gt; to be more or less feature
complete at this point, at least for a ‚Äò1.0‚Äô. That was the state on
Friday, and is still the state today. If something was left, I would
have had an immediate place to start this morning.&lt;/p&gt;

&lt;p&gt;I wasn‚Äôt feeling like going back to IPC benchmarking immediately, so I
ended up deciding to run a version of my &lt;a href=&quot;https://github.com/kamalmarhubi/shell-workshop&quot;&gt;Let‚Äôs Build a
Shell!&lt;/a&gt; workshop. I‚Äôve been wanting to do this for a while,
since I think it‚Äôs a pretty good way to get a deeper understanding of
how our programs are run. I need to file some issues to improve the
documentation a little, but I remain pretty pleased with how it‚Äôs set
up. Good job past me!&lt;/p&gt;

&lt;p&gt;After the workshop, I spent a bit of time deciding what to do next. I
think I‚Äôve settled on adding a memory mapped message builder to &lt;a href=&quot;https://capnproto.org/&quot;&gt;Cap‚Äôn
Proto&lt;/a&gt;‚Äôs C++ library. This was requested in a &lt;a href=&quot;https://groups.google.com/d/topic/capnproto/kLQOsxjkjxM/discussion&quot;&gt;recent mailing
list posting&lt;/a&gt;. It‚Äôll get me poking at the innards of
Cap‚Äôn Proto a little, which would be good for one of my potential bigger
project ideas for my time at RC: a shared memory transport for &lt;a href=&quot;https://capnproto.org/rpc.html&quot;&gt;Cap‚Äôn
Proto RPC&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Mon, 22 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/22/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/22/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes 2015-06-18</title>
        <description>&lt;p&gt;Lots of progress on &lt;a href=&quot;https://github.com/kamalmarhubi/lsaddr&quot;&gt;&lt;code&gt;lsaddr&lt;/code&gt;&lt;/a&gt; today! Unlike yesterday, most of these
commits are writing code rather than poking at it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --since=yesterday --reverse --oneline
0a695b0 Get IPv6 addresses from /proc/net/if_inet6
683d9c2 Fix typo in Makefile
8d61702 Add debug target to Makefile
686995b Add --list-interfaces option
8f2d3c4 Sort output of --list-interfaces
db95d00 Comment why we replace colon with null
ccf04d5 Introduce struct str_list to remove need for triple pointers
2209807 Use struct str_list in struct args
99cc8db Check interfaces exist using entries from /proc/net/dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some highlights: I now feel like I‚Äôve got this &lt;code&gt;lfind&lt;/code&gt; thing under control: I‚Äôm
using it to filter non-existent interfaces from the user‚Äôs arguments, as well
as to make sure I only output IP addresses for the specified interfaces. I also
implemented a &lt;code&gt;--list-interfaces&lt;/code&gt; option that does what it says. All this
information is pretty scattered and disorganised. Here are my sources:&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;code&gt;/proc/net/dev&lt;/code&gt;&lt;/dt&gt;
  &lt;dd&gt;contains a list of interfaces and some other data in a fairly
parse-unfriendly layout‚Äîtwo header rows, and the interface names have a colon
appended&lt;/dd&gt;
  &lt;dt&gt;&lt;code&gt;/proc/net/if_inet6&lt;/code&gt;&lt;/dt&gt;
  &lt;dd&gt;contains a list of IPv6 addresses along with some other data in a more
parse-friendly format, except that the IP addresses are given as 128-bits
hex-encoded, no colons and no zero-contractions‚Äînot ready for human
consumption&lt;/dd&gt;
  &lt;dt&gt;&lt;code&gt;ioctl(SIOCGIFCONF)&lt;/code&gt;&lt;/dt&gt;
  &lt;dd&gt;a system call that needs to be made on a socket file descriptor to get a list
of interfaces with IPv4 addresses as &lt;code&gt;struct sockaddr_in&lt;/code&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;So far &lt;code&gt;--include-loopback&lt;/code&gt; and &lt;code&gt;--include-link-local&lt;/code&gt; don‚Äôt do anything. I
started some refactoring to make them easier to impelment. I should be able to
get this wrapped up pretty soon!&lt;/p&gt;

&lt;p&gt;I also gave a presentation on writing manpages with &lt;a href=&quot;http://asciidoc.org/&quot;&gt;AsciiDoc&lt;/a&gt;. The tl;dr was
that it‚Äôs really easy! Take a look at the &lt;a href=&quot;https://github.com/kamalmarhubi/lsaddr/blob/master/lsaddr.1.txt&quot;&gt;AsciiDoc source&lt;/a&gt; for
the &lt;code&gt;lsaddr&lt;/code&gt; manpage. It starts off:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lsaddr(1)
=======

NAME
----
lsaddr - list active IP addresses

SYNOPSIS
--------
[verse]
*lsaddr* [ *-46* ] [*--include-loopback*] [*--include-ipv6-link-local*] [ _interface_ ... ]
*lsaddr --list-interfaces*

DESCRIPTION
-----------
List IP addresses of the specified __interface__s. By default, lists all IPv4
and IPv6 addresses, with the loopback interfaces and IPv6 link-local omitted.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here‚Äôs a screenshot of the formatted output in my terminal:
&lt;img src=&quot;/static/lsaddr-manpage.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;That‚Äôs it for now. I should be getting back to IPC stuff soon!&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/18/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/18/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes 2015-06-17</title>
        <description>&lt;p&gt;Not a lot to report today: I overslept and only got in at 11, and then left at
6 to go ringing. I did bring another recurser‚ÄîJess‚Äîalong with me, so that was
cool. I think she‚Äôll be back, too! I left ringing early to go and checkout the
&lt;a href=&quot;http://www.keyboard.io/&quot;&gt;Keyboardio Model 01&lt;/a&gt; in midtown. It‚Äôs a very attractive piece of
hardware, and has me tempted to order one. I‚Äôll need a second keyboard at some
point, right?&lt;/p&gt;

&lt;p&gt;On the &lt;a href=&quot;https://github.com/kamalmarhubi/lsaddr&quot;&gt;&lt;code&gt;lsaddr&lt;/code&gt;&lt;/a&gt; front, I figured out how to make &lt;code&gt;lfind&lt;/code&gt; go. I don‚Äôt understand
why, but I‚Äôll take my win for now. I‚Äôm also parsing &lt;code&gt;/proc/net/if_inet6&lt;/code&gt; to get
IPv6 addresses, though not yet including them in the output. I mostly pushed
characters around in source files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --since=yesterday --reverse --oneline
a08386b Fix typo in manpage
16fbff4 Change int to size_t in a couple of places
69300ac Use designated initializers instead of statements
614ef75 Rename ipv4_fd to sockfd and use AF_INET6
8d9aacc Check interface arguments exist
d21ecec Run clang-format
8f9fb9c Properly handle user specified interfaces
6d75545 Comment the repeated ioctl(SIOCGIFCONF)
3f03089 Improve handling of unspecified arguments
88a2eb5 Reformat struct initializer
8ea9224 Properly handle the IP version flags (IPv4 only)
bf08afa Move manpage doctype to a flag to a2x
cef15c4 Change manpage source file suffix to .1.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tomorrow‚Äôs work on &lt;code&gt;lsaddr&lt;/code&gt; will be to finish off IPv6 listing first thing in
the morning, and then do some restructuring to make option handling easier:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;get list of interfaces from /proc/net/dev
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;int list_interfaces(char ***interfaces, size_t *num_interfaces);&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;check against that list instead of using &lt;code&gt;ioctl&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;have a &lt;code&gt;struct address { char [ADDRESSBUFLEN] addr, char [IFNAMSIZ]
interface, enum {ipv4 = 4, ipv6 = 6} ip_version }&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;have an array of &lt;code&gt;struct address&lt;/code&gt; sorted by interface, version, addr&lt;/li&gt;
  &lt;li&gt;internal list of interfaces with pointers into list of &lt;code&gt;struct address&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other random things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I read &lt;a href=&quot;https://docs.google.com/document/pub?id=1IC9yOXj7j6cdLLxWEBAGRL6wl97tFxgjLUEHIX3MSTs&quot;&gt;Introducing the Journal&lt;/a&gt;, the post introducing &lt;code&gt;journald&lt;/code&gt;.
I‚Äôm new to this &lt;code&gt;systemd&lt;/code&gt; world so it was interesting to get some background.
The ‚Äòfrequently asked questions‚Äô are pretty terrible though, in that
intending-to-be-funny-but-mostly-condescending way that‚Äôs a bit too common in
tech.&lt;/li&gt;
  &lt;li&gt;I went to yoga in the early afternoon, which was a good idea. I need to go
more often. Physical activity is good.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 17 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/17/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/17/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes 2015-06-16</title>
        <description>&lt;p&gt;Today I continued working on my &lt;code&gt;lsaddr&lt;/code&gt; utility for listing IP addresses.
Here‚Äôs a quick update:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;there is now a &lt;a href=&quot;https://github.com/kamalmarhubi/lsaddr&quot;&gt;repository on GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I have a &lt;a href=&quot;https://github.com/kamalmarhubi/lsaddr/blob/master/lsaddr.adoc&quot;&gt;man page&lt;/a&gt; that I‚Äôm mostly pleased with; here‚Äôs the
synopsis:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;
lsaddr [ -46 ] [--include-loopback] [--include-ipv6-link-local] [ interface ... ]
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;I am checking that the supplied interfaces exist and reporting errors with
&lt;a href=&quot;http://linux.die.net/man/3/error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt;, which I discovered was the done thing by using &lt;code&gt;ltrace&lt;/code&gt; on
&lt;code&gt;ls does-not-exist&lt;/code&gt; :-)&lt;/li&gt;
  &lt;li&gt;I tried to use &lt;a href=&quot;http://linux.die.net/man/3/lfind&quot;&gt;&lt;code&gt;lfind&lt;/code&gt;&lt;/a&gt; to determine if interfaces were listed as
arguments, but wow what a mess that was&lt;sup id=&quot;fnref:lfind-mess&quot;&gt;&lt;a href=&quot;#fn:lfind-mess&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;; I scrapped that to come
back to it another day&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In other news, I read &lt;a href=&quot;http://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html&quot;&gt;this exciting post&lt;/a&gt; by Brendan Gregg on eBPF
and tracing in the kernel. Apparently it will soon be possible to gather
latency data from inside the kernel. I haven‚Äôt figured out if this could be
interesting for IPC benchmarks.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:lfind-mess&quot;&gt;

      &lt;p&gt;the closest C comes to having generics / parametric polymorphism is
&lt;code&gt;void *&lt;/code&gt;. With things like &lt;a href=&quot;http://linux.die.net/man/3/malloc&quot;&gt;&lt;code&gt;malloc&lt;/code&gt;&lt;/a&gt;, this is mostly fine. With algorithms
like &lt;code&gt;lfind&lt;/code&gt; and friends‚Ä¶ well you‚Äôre going to have a bad time. Just look
a this signature:&lt;/p&gt;

      &lt;p&gt;&lt;code&gt;
void *lfind(const void *key, const void *base, size_t *nmemb,
            size_t size, int(*compar)(const void *, const void *))
&lt;/code&gt;&lt;/p&gt;

      &lt;p&gt;I find &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find&quot;&gt;&lt;code&gt;std::find&lt;/code&gt;&lt;/a&gt; unfriendly, but this is a whole other level. &lt;a href=&quot;#fnref:lfind-mess&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 16 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/16/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/16/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes 2015-06-15: shipping, IPC, NUMA, AsciiDoc</title>
        <description>&lt;p&gt;Today I joined the ‚Äòshipping‚Äô checking group, instigated by &lt;a href=&quot;http://natwelch.com/&quot;&gt;Nat Welch&lt;/a&gt;.
The idea is to work towards actually shipping something, which I really want to
get better at while at RC.&lt;/p&gt;

&lt;p&gt;I decided on a simple utility to list IP addresses. This came out of my writing
on &lt;a href=&quot;/blog/2015/06/11/ifconfig-how-does-it-even/&quot;&gt;how &lt;code&gt;ifconfig&lt;/code&gt; works&lt;/a&gt;. &lt;a href=&quot;http://plover.com/~mjd/&quot;&gt;Mark Dominus&lt;/a&gt; said a
utility that just listed IP addresses would be handy, and he‚Äôs never come
across one. I did a little poking around the googles and stackoverflows, and
most answers involved &lt;code&gt;ifconfig&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, and either &lt;code&gt;sed&lt;/code&gt; or &lt;code&gt;awk&lt;/code&gt;. A few
listed the Linux only &lt;code&gt;ip addr show&lt;/code&gt; which still has a lot of cruft in its
output. I also came across another Linux only option, &lt;code&gt;hostname
--all-ip-addresses&lt;/code&gt;, which prints them one per line, ignoring loopback and link
local addresses.&lt;/p&gt;

&lt;p&gt;The last one is pretty close to what I would like, but it‚Äôs missing some handy
flags to specify IPv4 or IPv6, which interface, or whether to include link
local or loopback addresses. It‚Äôs also Linux only, which a standalone utility
could work around. I‚Äôm aiming to have a fairly polished first version for Linux
systems this week, possibly even dabbling in Debian packaging.&lt;/p&gt;

&lt;p&gt;Of course, right after deciding that, I got distracted following up on some
links &lt;a href=&quot;http://anil.recoil.org/&quot;&gt;Anil Madhavapeddy&lt;/a&gt; gave me last Thursday while he was at RC. It
turns out the IPC performance is of a lot of interest to virtualization people,
and he had this &lt;a href=&quot;https://github.com/avsm/ipc-bench&quot;&gt;big set of benchmarks&lt;/a&gt;. I also read through slides
from his FOSDEM 2012 talk entitled &lt;em&gt;The Wild West of UNIX I/O&lt;/em&gt;. This goes into
a lot of details around non-uniform memory architecture (NUMA) and how it
affects latency and throughput between core in a many core machine. It‚Äôs
incredibly fascinating that the interconnections between the cores can be
inferred from measuring IPC performance.&lt;/p&gt;

&lt;p&gt;Even more interesting to me was the little bit at the end on Fable I/O, an
‚Äòongoing attempt at a ‚Äúnew‚Äù sockets API for high-performance data‚Äô. Sadly, the
‚Äòongoing‚Äô part of this no longer seems valid: the best I could find was a
&lt;a href=&quot;https://github.com/ms705/libfable&quot;&gt;&lt;code&gt;libfable&lt;/code&gt;&lt;/a&gt; repository that hasn‚Äôt seen any updates in a couple of
years. This got me a bit excited, and I started reading up a bit more on NUMA
support in Linux. I came across a &lt;a href=&quot;http://lwn.net/Articles/486858/&quot;&gt;&lt;em&gt;Linux Weekly News&lt;/em&gt; article&lt;/a&gt;
from 2012 on NUMA aware scheduling support. So many things to think about:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the idea of home NUMA nodes for processes&lt;/li&gt;
  &lt;li&gt;moving physical pages between nodes while leaving virtual addresses intact&lt;/li&gt;
  &lt;li&gt;grouping processes together into NUMA groups that will always share a home
node&lt;/li&gt;
  &lt;li&gt;the performance gains possible by understanding and exploiting hardware
details&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On the performance note, a quote from the LWN article stands out:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Without the NUMA balancing patches, over time, the benchmark ended up with
just as many remote memory accesses as local accesses - allocated memory was
spread across the system. With the NUMA balancer, 86% of the memory accesses
were local, leading to a significant speedup.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;NUMA: serious business.&lt;/p&gt;

&lt;p&gt;After a while I was able to settle down again from all this IPC excitement and
think about how to approach the list-IP-addresses utility. I decided to go with
some &lt;a href=&quot;http://tom.preston-werner.com/2010/08/23/readme-driven-development.html&quot;&gt;README-driven development&lt;/a&gt;, and drafted up a README. After a bit,
I changed the aim to writing a manpage. This was driven by a secret desire to
use &lt;a href=&quot;http://asciidoc.org/&quot;&gt;AsciiDoc&lt;/a&gt; (see also: &lt;a href=&quot;http://asciidoctor.org/&quot;&gt;AsciiDoctor&lt;/a&gt;), as I‚Äôve been wanting to check it out as a Markdown alternative
for a while. I knew it had good support for manpage generation. In fact, the
&lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/&quot;&gt;&lt;code&gt;git&lt;/code&gt; docs&lt;/a&gt; are in AsciiDoc.&lt;/p&gt;

&lt;p&gt;So, current status:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I have some flags being parsed&lt;/li&gt;
  &lt;li&gt;can list IPv4 addresses&lt;/li&gt;
  &lt;li&gt;manpage needs some rewording and reworking&lt;/li&gt;
  &lt;li&gt;the tool needs a name. I had &lt;code&gt;lsip&lt;/code&gt;, after &lt;code&gt;lsof&lt;/code&gt;, but it looks wrong. I‚Äôm
now thinking &lt;code&gt;lsaddr&lt;/code&gt;. I am bad at names.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 15 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/15/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/15/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>ifconfig: how does it even?</title>
        <description>&lt;p&gt;I can already &lt;a href=&quot;/blog/2015/06/10/some-early-linux-ipc-latency-data/&quot;&gt;measure the latency&lt;/a&gt; of TCP sockets over the
loopback interface. I want to compare this to TCP sockets connecting to one of
the ‚Äòreal‚Äô addresses the machine has, to see if it‚Äôs any different. I could see
this being either the same as the loopback interface, or being slower. I‚Äôm way
below the level I have any real knowledge of at this point, so there‚Äôs only one
way to find out.&lt;/p&gt;

&lt;p&gt;But rather than hardcode in the IP addresses, or take them on the command line,
I want the benchmark to find them itself. One thing I want out of these
benchmarks is for them to build on any Linux system, and run without needing
machine-specific arguments.  When &lt;em&gt;I&lt;/em&gt; find out what IP addresses my machine
has, I use &lt;code&gt;ifconfig&lt;/code&gt;. But how does &lt;code&gt;ifconfig&lt;/code&gt; do it? I was about to Google the
answer when I realised this would be a perfect time use &lt;code&gt;strace&lt;/code&gt;, and so I did!&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;I just straced ifconfig to find out how it finds out which interfaces exist! /cc &lt;a href=&quot;https://twitter.com/b0rk&quot;&gt;@b0rk&lt;/a&gt;&lt;/p&gt;&amp;mdash; Kamal Marhubi (@kamalmarhubi) &lt;a href=&quot;https://twitter.com/kamalmarhubi/status/608735834905415680&quot;&gt;June 10, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;Here‚Äôs the quick summary of what happens:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;create sockets of both &lt;code&gt;AF_INET&lt;/code&gt; and &lt;code&gt;AF_INET6&lt;/code&gt; families&lt;/li&gt;
  &lt;li&gt;read &lt;code&gt;/proc/net/dev&lt;/code&gt; to get a complete list of interfaces; we‚Äôll need this
to get the addresses for &lt;code&gt;AF_INET6&lt;/code&gt; socket, as well as to get the list of
interfaces that don‚Äôt have an &lt;code&gt;AF_INET&lt;/code&gt; address&lt;/li&gt;
  &lt;li&gt;use the &lt;code&gt;SIOCGIFCONF&lt;/code&gt; &lt;code&gt;ioctl&lt;/code&gt; to get a list of addresses for &lt;code&gt;AF_INET&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;loop through the interface names that came from &lt;code&gt;/proc/net/dev&lt;/code&gt; and for each
one
    &lt;ul&gt;
      &lt;li&gt;read &lt;code&gt;/proc/net/if_inet6&lt;/code&gt; to get the IPv6 address for the interface, if
any&lt;/li&gt;
      &lt;li&gt;use a series of &lt;code&gt;ioctl&lt;/code&gt; calls to get data about the interface&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To see in more detail, take a look at &lt;a href=&quot;https://gist.github.com/kamalmarhubi/1dfc1fa302916e21975d&quot;&gt;this gist&lt;/a&gt; for an annotated
&lt;code&gt;strace&lt;/code&gt; of &lt;code&gt;ifconfig&lt;/code&gt; and &lt;code&gt;ifconfig -s&lt;/code&gt;.&lt;/p&gt;

</description>
        <pubDate>Thu, 11 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/11/ifconfig-how-does-it-even/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/11/ifconfig-how-does-it-even/</guid>
        
        
      </item>
    
      <item>
        <title>Some early Linux IPC latency data</title>
        <description>&lt;p&gt;I‚Äôve &lt;a href=&quot;https://github.com/kamalmarhubi/linux-ipc-benchmarks/commit/e06c93b54b4d13e1f78c64add9ac8a5cdf19b9ff&quot;&gt;added&lt;/a&gt; &lt;a href=&quot;https://github.com/kamalmarhubi/linux-ipc-benchmarks/commit/8f9094522465db54003f08da4d5b797e2944f47e&quot;&gt;benchmarks&lt;/a&gt; for UNIX domain
sockets and TCP sockets over the loopback interface. UNIX domain sockets were
super easy to implement thanks to the handy &lt;a href=&quot;http://man7.org/linux/man-pages/man2/socketpair.2.html&quot;&gt;&lt;code&gt;socketpair&lt;/code&gt;&lt;/a&gt;
function. It was not really any different from pipes. The difference is that
since sockets are full duplex, you only need to create one pair.  If the
processes were unrelated, or if I wanted to be able to accept multiple
connections, it would be much more like TCP sockets‚Äîie, a pain!&lt;/p&gt;

&lt;p&gt;I say a pain because, in doing this, I ‚Äòfound out‚Äô that, despite having written
a non-zero number of server applications, I‚Äôve never done socket programming
before. This wasn‚Äôt exactly a surprise, but it was definitely interesting to
realise how little I knew about how to go about it. Luckily, man pages! (And
&lt;a href=&quot;http://www.apuebook.com/index.html&quot;&gt;Advanced Programming in the UNIX Environment&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Here‚Äôs the quick tl;dr for TCP over IPv4::&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;to listen for incoming connections:
    &lt;ol&gt;
      &lt;li&gt;create a socket with &lt;code&gt;socket(AF_INET, SOCK_STREAM, 0 /* default protocol */)&lt;/code&gt;.&lt;sup id=&quot;fnref:default-proto&quot;&gt;&lt;a href=&quot;#fn:default-proto&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
      &lt;li&gt;bind it to a port with &lt;code&gt;bind(sockfd, addr, addrlen)&lt;/code&gt; where &lt;code&gt;addr&lt;/code&gt; is a
struct that specifies the address to bind to. For &lt;code&gt;AF_INET&lt;/code&gt;, this means
the IP and port. In my case, I used &lt;code&gt;INETADDR_LOOPBACK&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; to listen
on some available port on &lt;code&gt;127.0.0.1&lt;/code&gt;.&lt;sup id=&quot;fnref:htonl&quot;&gt;&lt;a href=&quot;#fn:htonl&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
      &lt;li&gt;start listening on the socket with &lt;code&gt;listen(sockfd, 1 /* backlog */)&lt;/code&gt;. I
used a &lt;code&gt;backlog&lt;/code&gt; of 1 because I only expect a single incoming connection.&lt;/li&gt;
      &lt;li&gt;finally, call &lt;code&gt;accept(sockfd, NULL /* addr */, NULL /* addrlen */)&lt;/code&gt; to
block until a connection comes in, which returns a new file descriptor to
talk to the connecting process. I pass in &lt;code&gt;NULL&lt;/code&gt; for the &lt;code&gt;addr&lt;/code&gt; because I
don‚Äôt care who‚Äôs talking to me!&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;to connect to another process that‚Äôs listening:
    &lt;ol&gt;
      &lt;li&gt;create a socket with &lt;code&gt;socket(AF_INET, SOCK_STREAM, 0 /* default protocol */)&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;connect to the remote process with &lt;code&gt;connect(sockfd, addr, addrlen)&lt;/code&gt;. The
&lt;code&gt;addr&lt;/code&gt; specifies the address to connect to; again for &lt;code&gt;AF_INET&lt;/code&gt; this means
the IP and port.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This brings me up to having programs to test latency for four IPC mechanisms:
- pipes
- eventfd
- UNIX domain sockets
- TCP sockets over the loopback interface&lt;/p&gt;

&lt;p&gt;Here is some early latency data from my machine, with emphasis on the tail latencies:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;¬†&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;50&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;75&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;90&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99.9&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99.99&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99.999&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pipes&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4255&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4960&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5208&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5352&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7814&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;16214&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;31290&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;eventfd&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4353&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4443&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4760&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5053&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9445&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;14573&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;68528&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;af_unix&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1439&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1621&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1655&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1898&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2681&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;11512&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;54714&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;af_inet_loopback&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7287&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7412&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7857&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;8573&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;17412&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;20515&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;37019&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Units are nanoseconds. Time is measured using &lt;code&gt;clock_gettime&lt;/code&gt; with
&lt;code&gt;CLOCK_MONOTONIC&lt;/code&gt;. The quantiles are for a million measurements; in all cases,
the binary was run with flags &lt;code&gt;--warmup-iters=10000 --iters=1 --repeat=1000000&lt;/code&gt;
(see below).&lt;/p&gt;

&lt;p&gt;For me, the biggest surprise was how much faster UNIX domain sockets were than
anything else, and in particular, how much faster they are than eventfd. Or
that they are faster at all. The &lt;code&gt;read&lt;/code&gt; call in each case blocks until a
corresponding &lt;code&gt;write&lt;/code&gt;. I would have thought eventfd had the minimal amount of
extra work beyond that, since all it does is read and modify a &lt;code&gt;uint64_t&lt;/code&gt;. In
fairness, each of the other programs are writing a single byte at present, but
I doubt the difference will be so drastic.&lt;/p&gt;

&lt;p&gt;Another fun thing is to see difference in `latency when pinning the two
processes to specific CPUs. My machine has a dual core processor, where each
processor has 2 hardware threads. Here‚Äôs a quick look at latencies for pipes
with different CPU affinities:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Percentile&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;50&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;75&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;90&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99.9&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99.99&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;99.999&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;default&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4255&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4960&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5208&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5352&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7814&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;16214&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;31290&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;same CPU&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2386&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2402&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2564&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3134&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;12255&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;15126&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;28225&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;same core&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4232&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4270&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4395&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4788&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;14408&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;17101&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;39052&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;different core&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5043&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5101&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5170&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5772&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;11894&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;38726&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;398796&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I was expecting a difference between different cores and not, since it requires
a trip through the L3 cache. I have no realy idea of what difference I was
expecting, but a microsecond could make sense if multiple locations needed to
be accessed. This stuff is beyond my ken, so I‚Äôm just guessing.&lt;/p&gt;

&lt;p&gt;What I was &lt;em&gt;not&lt;/em&gt; expecting, was a dramatic difference between ‚Äòsame CPU‚Äô and
‚Äòsame core‚Äô. The CPUs are hardware threads on a single core. I can‚Äôt think of
any reason there would be such a difference. I do want to check that it‚Äôs not
due to scheduling weirdness, so I‚Äôll probably boot up in single user mode at
some point to give it another go.&lt;/p&gt;

&lt;p&gt;If you want to run these on your own system, clone the &lt;a href=&quot;https://github.com/kamalmarhubi/linux-ipc-benchmarks&quot;&gt;repo&lt;/a&gt; and run &lt;code&gt;make&lt;/code&gt;.
There will be four binaries produced, one for each of the mechanisms.  They all
take the same command line flags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  -c, --child-cpu=CPUID      CPU to run the child on; default is to let the
                             scheduler do as it will
  -i, -n, --iters=COUNT      number of iterations to measure; default: 100000
  -p, --parent-cpu=CPUID     CPU to run the parent on; default is to let the
                             scheduler do as it will
  -r, --repeat=COUNT         number of times to repeat measurement; default: 1
  -w, --warmup-iters=COUNT   number of iterations before measurement; default:
                             1000
  -?, --help                 Give this help list
      --usage                Give a short usage message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:default-proto&quot;&gt;

      &lt;p&gt;The default protocol for &lt;code&gt;SOCK_STREAM&lt;/code&gt; for the &lt;code&gt;AF_INET&lt;/code&gt;
socket family is TCP. &lt;a href=&quot;#fnref:default-proto&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:htonl&quot;&gt;

      &lt;p&gt;A fun little thing to be aware of is that the &lt;code&gt;addr&lt;/code&gt; must contain the IP
address in network byte order. This necessitates converting the IP address
and port using &lt;code&gt;htonl&lt;/code&gt; and &lt;code&gt;htons&lt;/code&gt;, respectively, to convert the IP from
&lt;em&gt;h_ost _to&lt;/em&gt; _n_etwork byte order (the &lt;code&gt;l&lt;/code&gt; stands for &lt;code&gt;long&lt;/code&gt;, which in this
case means a &lt;code&gt;uint32_t&lt;/code&gt; because &lt;code&gt;long&lt;/code&gt;s used to be shorter; the &lt;code&gt;s&lt;/code&gt; stands
for &lt;code&gt;short&lt;/code&gt; which have stayed short at 16 bits long). &lt;a href=&quot;#fnref:htonl&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/10/some-early-linux-ipc-latency-data/</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/10/some-early-linux-ipc-latency-data/</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes: 2015-06-08</title>
        <description>&lt;h1 id=&quot;linux-ipc-stuff&quot;&gt;Linux IPC stuff&lt;/h1&gt;
&lt;p&gt;I‚Äôm getting closer to having some data on latencies for pipes and eventfds. I
reworked the little programs to easily dump timings for multiple runs. Next
step is to figure out how to visualise it. Likely I‚Äôll use iPython Notebook and
Pandas.&lt;/p&gt;

&lt;p&gt;On the way, I found out a thing‚Äîone of those obvious-in-retrospect things. Both
the pipes and eventfd programs I wrote have the same structure. They start a
child process that acts as a server that responds as soon as it receives a
message. The child just runs a loop like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;for (;;) {
  char msg;
  read(rx_fd, &amp;amp;msg, 1);
  write(tx_fd, &quot;1&quot;, 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I implemented this for pipes first, and this works great. A &lt;code&gt;read&lt;/code&gt; on a pipe
whose write end is closed will return 0 to signal end of file. A &lt;code&gt;write&lt;/code&gt; on a
pipe whose read end is closed results in a &lt;code&gt;SIGPIPE&lt;/code&gt; signal. The result is that
once the parent closes its pipes‚Äîwhether explicitly or on exit‚Äîthe child will
die because the default action for &lt;code&gt;SIGPIPE&lt;/code&gt; is to terminate the process.&lt;/p&gt;

&lt;p&gt;With eventfds, there is no analogous signal. It would actually be a bit odd.
Pipes have two ends, and each gets its own file descriptor. When the last file
descriptor referring to one of the ends is closed, then the &lt;code&gt;EOF&lt;/code&gt; / &lt;code&gt;SIGPIPE&lt;/code&gt;
behaviour kicks in. To get something similar to happen with eventfds, the
special behaviour would have to kick in when only one file descriptor
references the eventfd object. But right after the call to &lt;code&gt;eventfd&lt;/code&gt;, there is
just one file descriptor referencing it. I suppose it could be special cased to
trigger when the number of open file descriptors goes &lt;em&gt;down&lt;/em&gt; to one, but it‚Äôs
also completely reasonable that it wouldn‚Äôt.&lt;/p&gt;

&lt;p&gt;All that is to say, the child doesn‚Äôt terminate when the parent does, and I ended up with this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pgrep eventfd | head
6123
6131
6138
6145
6153
6160
6531
6538
6545
6553
$ pgrep eventfd | wc -l
172
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That‚Äôs a lot of zombies! Don‚Äôt worry, I killed them. With FIRE^W &lt;code&gt;pkill&lt;/code&gt;. I
still have to fix the problem, but the solution is pretty easy: kill the child
before the parent exits.&lt;/p&gt;

&lt;h1 id=&quot;other-stuff&quot;&gt;Other stuff&lt;/h1&gt;
&lt;p&gt;The internet went down for a bit at RC today. I used the time to add an index
page to this blog, &lt;a href=&quot;https://twitter.com/kamalmarhubi/status/607967764620431361&quot;&gt;making some people happy&lt;/a&gt;. It felt silly to
use lack of internet to make internet, but there you go.&lt;/p&gt;

&lt;p&gt;During the internet outage, I also brainstormed with &lt;a href=&quot;https://twitter.com/SimplyAhmaz1ng&quot;&gt;Ahmed&lt;/a&gt; a bit on grammar
ideas for his Arabic programming language. I was thinking it would be cool to
integrate some Arabic grammar into the language. For example, use the
possessive for property access, and allow the &lt;a href=&quot;https://en.wikipedia.org/wiki/Arabic_grammar#Enclitic_pronouns&quot;&gt;attached pronouns&lt;/a&gt; to
be a default argument like Perl‚Äôs &lt;code&gt;$_&lt;/code&gt;. We decided they wouldn‚Äôt be a great
idea because it could end up in a sort of uncanny valley where something it
looks like should work but it doesn‚Äôt.&lt;/p&gt;

&lt;p&gt;I paired with &lt;a href=&quot;https://twitter.com/optimistsinc&quot;&gt;Jess&lt;/a&gt; who is learning Haskell to do some lattice-based
cryptography stuff. But step 1 is tic-tac-toe. We did some refactoring, and I
pointed out a couple of useful things like using &lt;code&gt;@&lt;/code&gt; in a pattern to name the
whole match. Somehow I‚Äôm pretty happy helping people with Haskell, even though
I‚Äôm not really that interested in it anymore myself. Maybe it‚Äôs just because
it‚Äôs something I know and so can help with.&lt;/p&gt;

&lt;p&gt;Allison Parish is a resident for the next two weeks. She gave a talk in the
evening on &lt;a href=&quot;http://www.decontextualize.com/projects/nite/&quot;&gt;new interfaces for textual expression&lt;/a&gt;. Do take a look at
that link, her projects are really cool! She‚Äôs aiming to put together a bunch
of prototypes while at RC, and I‚Äôm really excited to see what she gets up to.&lt;/p&gt;

&lt;h1 id=&quot;random&quot;&gt;Random&lt;/h1&gt;

&lt;p&gt;On the way to eBay for Allison‚Äôs talk, I stopped by Union Square to buy an
apple. I also got a ‚Äòcocktail‚Äô of apple juices for free‚ÄîI stopped to look at a
stall that was packing up, and their demo bottles were mostly empty.  The
person poured them into one bottle and just gave it to me.&lt;/p&gt;

&lt;p&gt;I then took my apple and juice to a table on Broadway and sat down. Two people
next to me were eating burgers and speaking Qu√©becois French. I wasn‚Äôt going to
insert myself until I heard ‚ÄòRachel et Saint-Hubert‚Äô, which is an intersection
close to where I live. They were discussing the burger, and so I asked (in
French) if they were talking about L‚ÄôAnecdote, a burger place at that corner. I
think this was a fun surprise for them, and we had a little chat about what
brought us to New York. Even more fun, I was wearing my ‚Äò&lt;a href=&quot;https://en.wikipedia.org/wiki/Five_Roses_Flour&quot;&gt;Farine Five
Roses&lt;/a&gt;‚Äô t-shirt, marking me‚Äîin one of their words‚Äîas &lt;em&gt;vrai
Montr√©alais&lt;/em&gt;!&lt;/p&gt;

</description>
        <pubDate>Mon, 08 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/08/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/08/recurse-center-lab-notes</guid>
        
        
      </item>
    
      <item>
        <title>Recurse Center lab notes: 2015-06-03‚Äì2015-06-07</title>
        <description>&lt;p&gt;I had a busy week with my parents visiting. I was leaving RC a bit earlier than
I would have otherwise, and also getting to bed later‚Äîthey were staying in
midtown, and I‚Äôm in Flatbush. As a result, I let my posting slide a bit, and
this is me catching up. I‚Äôll also plan to write lab notes such as these each
normal RC day, ie Monday through Thursday.&lt;/p&gt;

&lt;h1 id=&quot;linux-ipc&quot;&gt;Linux IPC&lt;/h1&gt;
&lt;p&gt;Ostensibly, the main project I‚Äôm working on right now is investigating Linux
IPC. The eventual plan is to try and implement a share memory transport for
&lt;a href=&quot;http://capnproto.org/&quot;&gt;Cap‚Äôn Proto&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As a start, I implemented a couple of small programs to measure latency for
&lt;a href=&quot;http://man7.org/linux/man-pages/man2/pipe.2.html&quot;&gt;pipes&lt;/a&gt; and &lt;a href=&quot;http://man7.org/linux/man-pages/man2/eventfd.2.html&quot;&gt;eventfd&lt;/a&gt;. It looks like the round trip time on my machine is on
the order of a couple of microseconds. It varies a little depending on if I pin
the communicating processes to the same core or not. This was nice to see,
since it would require going over the L3 cache. However, the difference was on
the order of a couple of hundred nanoseconds, which is more than I expected.
I‚Äôll aim to get some data and draw some histograms early this coming week.&lt;/p&gt;

&lt;h1 id=&quot;javascript-distraction&quot;&gt;JavaScript distraction&lt;/h1&gt;
&lt;p&gt;Somehow I ended up with a bunch of JavaScript related tabs open. I think I
blame Monica for it, as I was catching up on Twitter and saw her post about
&lt;a href=&quot;http://polymer-project.org/&quot;&gt;Polymer&lt;/a&gt; 1.0:&lt;/p&gt;
&lt;blockquote class=&quot;twitter-tweet&quot; lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;üéâüöÄ&lt;a href=&quot;https://twitter.com/polymer&quot;&gt;@polymer&lt;/a&gt; turns 1! SO excited to be part of this release ‚Äî everything is faster and  the elements are shinier! üëè‚ù§Ô∏è&amp;#10;&amp;#10;&lt;a href=&quot;http://t.co/fSzBi1s8bD&quot;&gt;http://t.co/fSzBi1s8bD&lt;/a&gt;&lt;/p&gt;&amp;mdash; Monica Dinosaurescu (@notwaldorf) &lt;a href=&quot;https://twitter.com/notwaldorf/status/604324257460453376&quot;&gt;May 29, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;Eventually (or maybe soon?) I want to start learning JS. Or ECMAScript 2015 to
be more specific. Or maybe even some ES7 features, like &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt;. I
was planning to learn React for some nifty front-end isomorphic buzzword
compliance, but I‚Äôm not sure now. Maybe Polymer? Maybe some other &lt;a href=&quot;http://vdom-benchmark.github.io/vdom-benchmark/&quot;&gt;virtual DOM
thingamy&lt;/a&gt; thing?&lt;/p&gt;

&lt;h1 id=&quot;make-distraction&quot;&gt;make distraction&lt;/h1&gt;

&lt;p&gt;I did a &lt;a href=&quot;https://github.com/kamalmarhubi/linux-ipc-benchmarks/commit/20cdb2e254a02de85180c1d4708ecfb7faa9812e&quot;&gt;refactor&lt;/a&gt; of my IPC programs to allow them to share a &lt;code&gt;main&lt;/code&gt; that
handled command line arguments and other stuff. This required me to rejigger
the &lt;code&gt;Makefile&lt;/code&gt; to have both programs depend on the new source file, and to link
it in. I asked Twitter the wrong question:&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;is actually learning make a worthwhile pursuit?&lt;/p&gt;&amp;mdash; Kamal Marhubi (@kamalmarhubi) &lt;a href=&quot;https://twitter.com/kamalmarhubi/status/607295232821075969&quot;&gt;June 6, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;The responses lead me to expend small but non-zero time on this. I learned that
&lt;code&gt;$@&lt;/code&gt;‚Äô and &lt;code&gt;$&amp;lt;&lt;/code&gt; are &lt;a href=&quot;https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html#Automatic-Variables&quot;&gt;meaningful variable names&lt;/a&gt;. Also that it‚Äôs
possible to build a static site generator driven by &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-conversation=&quot;none&quot; lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;a href=&quot;https://twitter.com/kamalmarhubi&quot;&gt;@kamalmarhubi&lt;/a&gt; I love make! It saved my life so many times. I&amp;#39;m writing a static site generator in a Makefile.&lt;/p&gt;&amp;mdash; linse   (@linse) &lt;a href=&quot;https://twitter.com/linse/status/607315482107117568&quot;&gt;June 6, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

</description>
        <pubDate>Sun, 07 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://kamalmarhubi.com/blog/2015/06/07/recurse-center-lab-notes</link>
        <guid isPermaLink="true">http://kamalmarhubi.com/blog/2015/06/07/recurse-center-lab-notes</guid>
        
        
      </item>
    
  </channel>
</rss>
