<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Things you could do with the Rust AST</title>
    <meta name="description" content="">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://kamalmarhubi.com/blog/2016/06/02/things-you-could-do-with-the-rust-ast/">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Kamal Marhubi</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Things you could do with the Rust AST</h1>
    <p class="post-meta">Jun 2, 2016</p>
  </header>

  <article class="post-content">
    <p>Lately I’ve been contributing to <a href="https://github.com/rust-lang-nursery/rustfmt">rustfmt</a>, which is a tool for formatting Rust code. Right now, it formats entire files, which is great if you keep your entire project formatted by rustfmt. If you’re adding code to an existing unrustfmted project, using rustfmt leads to big diffs where most of the changes are just formatting. These can be really annoying to review, so the feature I’m working on is to allow it to format just parts of files. Then you could just reformat the parts you actually changed, making things much nicer for whoever is reviewing the change.</p>

<p>Working on rustfmt has meant getting a bit of familiarity with Rust’s abstract syntax tree (AST), which is how the rustc compiler represents source code. The AST has nodes to represent each expression, statement, function, module, and all the other bits of syntax that make up a Rust program.
It’s been interesting and kind of cool to work with, and I wanted to share a bit!</p>

<h2 id="libsyntax-and-syntexsyntax">libsyntax and syntex_syntax</h2>

<p>The Rust compiler’s own parsing code is in a library called libsyntax. Sadly for programs that aren’t rustc, this is a private library inside the compiler source repository. If you’re willing to use the nightly compiler, there are some incantations that will tell rustc to let you use these internal libraries, but it’s not really encouraged. The Rust folks want to be able to make changes as they keep working on making Rust better, and not have to worry about breaking outside projects.</p>

<p>But someone maintains a copy in Crates.io called <a href="https://crates.io/crates/syntex_syntax">syntex_syntax</a>, with modifications to build with stable Rust. It’s part of a suite of tools for generating Rust code, initially created for <a href="https://github.com/serde-rs/serde">a serialization framework</a>.</p>

<p>The upshot of this is that we can just add the line</p>

<pre><code>syntex_syntax = "0.33"
</code></pre>

<p>to our <code>Cargo.toml</code> file, and then we can parse Rust code in our programs!</p>

<h2 id="a-small-example-of-working-with-the-ast">A small example of working with the AST</h2>

<p>To get an idea of what working with the AST looks like, let’s look at a small example: printing the number of arguments for each function in a file.</p>

<p>syntex_syntax has a <code>Visitor</code> trait you can implement to walk an AST. The default implementation just walks the whole tree and doesn’t do anything else. To write a custom visitor, you can implement the <code>visit</code> function for the node type you’re interested in, and leave the rest out. If you’re more used to Java-esque type systems, you can imagine inheriting from a base <code>DefaultVisitor</code> class, and overriding the functions relating to the syntactic elements you are interested in.</p>

<p>For our example, we override the implementation for <code>visit_fn</code> to store the funciton name and number of arguments in a hashmap. The <a href="https://github.com/kamalmarhubi/syntex-syntax-example">full code is up on GitHub</a>, but here are the important parts:</p>

<pre><code>struct CountFnArgs&lt;'a&gt; {
    arg_counts: HashMap&lt;String, usize&gt;,
    // The codemap is necessary to go from a `Span` to actual line &amp; column
    // numbers for closures.
    codemap: &amp;'a CodeMap,
}

impl&lt;'v, 'a&gt; Visitor&lt;'v&gt; for CountFnArgs&lt;'a&gt; {
    fn visit_fn(&amp;mut self,
                fn_kind: FnKind&lt;'v&gt;,
                fn_decl: &amp;'v ast::FnDecl,
                block: &amp;'v ast::Block,
                span: Span,
                _id: ast::NodeId) {
        let fn_name = match fn_kind {
            FnKind::ItemFn(id, _, _, _, _, _) |
            FnKind::Method(id, _, _) =&gt; id.name.as_str().to_string(),
            FnKind::Closure =&gt; format!("&lt;closure at {}&gt;", self.format_span(span)),
        };

        self.arg_counts.insert(fn_name, fn_decl.inputs.len());

        // Continue walking the rest of the funciton so we pick up any functions
        // or closures defined in its body.
        visit::walk_fn(self, fn_kind, fn_decl, block, span);
    }
}

fn count_fn_args(krate: &amp;ast::Crate, codemap: &amp;CodeMap) -&gt; HashMap&lt;String, usize&gt; {
    let mut visitor = CountFnArgs {
        arg_counts: HashMap::new(),
        codemap: codemap,
    };
    visitor.visit_mod(&amp;krate.module, krate.span, 0);

    visitor.arg_counts
}
</code></pre>

<p>Rust’s pattern matching really shines when working with ASTs. You can get a small glimpse of it here: we match on the <code>FnKind</code> to see if the function is a method, a free function (<code>ItemFn</code>), or a closure. In the first two cases, we just pull out the function’s name; in the third we get the source location to identify it better.</p>

<p>Here’s the output for our little program running on its own source:</p>

<pre><code>FUNCTION                         ARGS
&lt;closure at 40:19-40:39&gt;         2
count_fn_args                    2
format_loc                       1
format_span                      2
main                             0
parse                            2
visit_fn                         6
visit_mac                        2
</code></pre>

<p>Not bad!</p>

<h2 id="things-you-can-do-with-an-ast">Things you can do with an AST</h2>

<p>Being able to programmatically parse and work with source code opens up all kinds of cool possibilities. Here are a few.</p>

<h3 id="format-rust-code">Format Rust code!</h3>

<p>As I kind of mentioned at the start of this post, rustfmt uses the AST to format code. First it parses a file into an AST. Then it walks the tree, recursively printing each node according to a bunch of formatting fules. The <a href="https://github.com/rust-lang-nursery/rustfmt/blob/master/Design.md#operate-on-the-ast">design document</a> gives bit more background on the approach, and why rustfmt works the way it does.</p>

<h3 id="throughly-test-c-apis">Throughly test C APIs</h3>

<p>The <a href="https://github.com/rust-lang/libc">libc crate</a> is full of function declarations, struct definitions, and constants for working with system libraries. It has a really cool and thorough test suite that makes sure all the items match what’s in the system C headers. It works by parsing the Rust source, and <em>generating C code</em> where it tests for equality of constants and matching type signatures and so on. It then generates some Rust code that calls the generated C code to check everything. So much code generation!</p>

<p>Here’s a snippet of the generated C code to give you an idea of what it’s like:</p>

<pre><code>static int __test_const_O_RDONLY_val = O_RDONLY;
int* __test_const_O_RDONLY(void) {
    return &amp;__test_const_O_RDONLY_val;
}


static int __test_const_O_WRONLY_val = O_WRONLY;
int* __test_const_O_WRONLY(void) {
    return &amp;__test_const_O_WRONLY_val;
}


static int __test_const_O_RDWR_val = O_RDWR;
int* __test_const_O_RDWR(void) {
    return &amp;__test_const_O_RDWR_val;
}
</code></pre>

<p>and it goes on and on and on for over 10,000 lines! The result is that the definitions in libc can be pretty safely relied on to match the definitions on the platform you’re working with, which is really great for doing systems programming (<a href="http://kamalmarhubi.com/blog/2016/04/13/rust-nix-easier-unix-systems-programming-3/">one of my favourite things</a>).</p>

<h3 id="other-things-you-could-do">Other things you could do!</h3>

<p>There are all kinds of other things we can do! For example, it should be possible to build a syntax-aware find-and-replace tool to make some refactorings easier. I’m imagining something like <a href="https://github.com/facebook/jscodeshift">FaceBook’s jscodeshift tool for JavaScript</a>, or their <a href="https://github.com/facebook/pfff/wiki/Spatch">spatch</a> for PHP and some other languages. This would be great for situations like where you just changed the type of the third argument of that function from <code>String</code> to <code>&amp;str</code> (string slice) and now you have to change all the call sites everywhere to call <code>.as_str()</code><sup id="fnref:fn-asref"><a href="#fn:fn-asref" class="footnote">1</a></sup>.</p>

<p>If we’re willing to go a bit deeper into compiler internals—and require nighty Rust to build our project—we can also make tools that use type information. There’s no reason something like <a href="https://www.haskell.org/hoogle/">Hoogle</a> couldn’t exist for Rust. Hoogle was amazing back when I used to write Haskell. You search by <em>type signature</em>. It’s kind of magical to be able to say <a href="https://www.haskell.org/hoogle/?hoogle=%5Ba%5D+-%3E+Int">“I have a a list and I want an int”</a> and it would have the <code>length</code> function at the top of the results page.</p>

<p><a href="https://github.com/mozilla/dxr">DXR</a> is an example of an exisiting project using type information in Rust. It’s an indexing engine and web interface with fancy cross referencing of source code. As an example, you can <a href="https://dxr.mozilla.org/rustfmt/source/src/visitor.rs#133">browse things around the <code>visit_fn</code> function in rustfmt</a>. It’s really cool! This kind of interwingly source browsing can be really really powerful for understanding a new codebase.</p>

<p>I really love tools like these that make developers’ lives easier. If you have any ideas for Rust, or examples from other languages to “borrow”, please send them my way!</p>

<p><br /></p>

<hr />

<p><small><em>Thanks to Julia Evans for feedback on this post, and for suggesting I write it in the first place!</em></small></p>
<div class="footnotes">
  <ol>
    <li id="fn:fn-asref">

      <p>Though you should consider changing the third argument of that function to take <a href="http://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef&lt;str&gt;</code></a> instead. That way you could pass either <code>String</code>, or a <code>&amp;str</code>. The <a href="http://doc.rust-lang.org/std/convert/index.html">conversion traits</a> are really really great! :-) <a href="#fnref:fn-asref" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">
    <p style="font-size: 14px; color: #424242; font-style: italic">I am often available for consulting—contact me for details.</p>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:kamal@marhubi.com">kamal@marhubi.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/kamalmarhubi">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">kamalmarhubi</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/kamalmarhubi">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">kamalmarhubi</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text"></p>
      </div>
    </div>

  </div>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-39994628-3', 'auto');
    ga('send', 'pageview');

  </script>

</footer>


  </body>

</html>
